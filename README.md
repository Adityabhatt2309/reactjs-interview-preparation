# Reactjs-interview-preparation
Comprehensive React.js interview preparation repository covering beginner to advanced questions, React hooks, real interview scenarios, and practical concepts for frontend developers.
Alright üî•
Below is the **COMPLETE REACT JS TOPICS LIST** ‚Äî from **absolute basic ‚Üí advanced ‚Üí expert level**.
‚úÖ **Only topic names**
‚úÖ **Nothing missed**
‚úÖ **Interview + real-world + production ready**

You can treat this as a **React Master Checklist**.

---

# ‚öõÔ∏è REACT JS COMPLETE TOPICS (BASIC ‚Üí ADVANCED)
## üü¢ React Questions Index

### 1. React Fundamentals
1. [What is React](#1-what-is-react)
2. [Why React](#2-why-react)
3. [History of React](#3-history-of-react)
4. [SPA (Single Page Application)](#4-spa-single-page-application)
5. [React vs Angular vs Vue](#5-react-vs-angular-vs-vue)
6. [React Architecture](#6-react-architecture)
7. [React Features](#7-react-features)
8. [Virtual DOM](#8-virtual-dom)
9. [Real DOM vs Virtual DOM](#9-real-dom-vs-virtual-dom)
10. [React Reconciliation](#10-react-reconciliation)

### 2. Environment Setup
11. [Node.js & npm basics](#11-nodejs--npm-basics)
12. [npx](#12-npx)
13. [Create React App](#13-create-react-app-cra)
14. [Vite](#14-vite)
15. [Folder Structure](#15-folder-structure)
16. [Development vs Production build](#16-development-vs-production-build)
17. [Babel](#17-babel)
18. [Webpack basics](#18-webpack-basics)

### 3. JSX
19. [What is JSX](#19-what-is-jsx)
20. [JSX Syntax](#20-jsx-syntax)
21. [JSX Expressions](#21-jsx-expressions)
22. [JSX Attributes](#22-jsx-attributes)
23. [JSX Fragments](#23-jsx-fragments)
24. [JSX vs HTML](#24-jsx-vs-html)
25. [Conditional Rendering in JSX](#25-conditional-rendering-in-jsx)

### 4. Components
26. [What is a Component](#26-what-is-a-component)
27. [Functional Components](#27-functional-components)
28. [Class Components](#28-class-components)
29. [Stateless Components](#29-stateless-components)
30. [Stateful Components](#30-stateful-components)
31. [Reusable Components](#31-reusable-components)
32. [Component Naming Rules](#32-component-naming-rules)
33. [Component Composition](#33-component-composition)

### 5. Props
34. [Props Introduction](#34-props-introduction)
35. [Passing Props](#35-passing-props)
36. [Props Destructuring](#36-props-destructuring)
37. [Default Props](#37-default-props)
38. [Props Validation](#38-props-validation)
39. [Children Props](#39-children-props)
40. [Props vs State](#40-props-vs-state)

### 6. State
41. [What is State](#41-what-is-state)
42. [useState Hook](#42-usestate-hook)
43. [Updating State](#43-updating-state)
44. [State Immutability](#44-state-immutability)
45. [Lifting State Up](#45-lifting-state-up)
46. [Controlled Components](#46-controlled-components)
47. [Uncontrolled Components](#47-uncontrolled-components)

### 7. Event Handling
48. [Handling Events in React](#48-handling-events-in-react)
49. [Synthetic Events](#49-synthetic-events)
50. [Passing Arguments to Events](#50-passing-arguments-to-events)
51. [Event Binding](#51-event-binding)
52. [Prevent Default](#52-prevent-default)
53. [Event Bubbling](#53-event-bubbling-in-react)

### 8. Conditional Rendering
54. [if-else Rendering](#54-if-else-rendering)
55. [Ternary Operator](#55-ternary-operator)
56. [Logical AND](#56-logical-and-)
57. [Switch Case Rendering](#57-switch-case-rendering)
58. [Conditional Components](#58-conditional-components)

### 9. Lists & Keys
59. [Rendering Lists](#59-rendering-lists)
60. [map in JSX](#60-map-in-jsx)
61. [Keys](#61-keys)
62. [Index as Key](#62-index-as-key-antipattern)
63. [Dynamic Lists](#63-dynamic-lists)

### 10. Styling
64. [CSS in React](#64-css-in-react)
65. [Inline Styling](#65-inline-styling)
66. [CSS Modules](#66-css-modules)
67. [Styled Components](#67-styled-components)
68. [SCSS/SASS](#68-scsssass)
69. [Tailwind CSS](#69-tailwind-css)
70. [Dynamic Styles](#70-dynamic-styles)

### 11. Forms
71. [Forms in React](#71-forms-in-react)
72. [Controlled Forms](#72-controlled-forms)
73. [Uncontrolled Forms](#73-uncontrolled-forms)
74. [Form Validation](#74-form-validation)
75. [Multiple Inputs](#75-multiple-inputs)
76. [Checkbox & Radio](#76-handling-checkbox--radio)
77. [Select Dropdown](#77-select-dropdown)

### 12. Hooks Core
78. [What are Hooks](#78-what-are-hooks)
79. [Rules of Hooks](#79-rules-of-hooks)
80. [useState](#80-usestate)
81. [useEffect](#81-useeffect)
82. [useEffect Cleanup](#82-useeffect-cleanup)
83. [Dependency Array](#83-dependency-array)
84. [Multiple useEffect](#84-multiple-useeffect)

### 13. Hooks Advanced
85. [useContext](#85-usecontext)
86. [Context API](#86-context-api)
87. [useReducer](#87-usereducer)
88. [useRef](#88-useref)
89. [useImperativeHandle](#89-useimperativehandle)
90. [useLayoutEffect](#90-uselayouteffect)
91. [useCallback](#91-usecallback)
92. [useMemo](#92-usememo)
### 13. Hooks Advanced (continued)
93. [Custom Hooks](#93-custom-hooks)

### 14. Lifecycle Methods
94. [Component Lifecycle](#94-component-lifecycle)
95. [Mounting Phase](#95-mounting-phase)
96. [Updating Phase](#96-updating-phase)
97. [Unmounting Phase](#97-unmounting-phase)
98. [componentDidMount](#98-componentdidmount)
99. [componentDidUpdate](#99-componentdidupdate)
100. [componentWillUnmount](#100-componentwillunmount)
101. [getDerivedStateFromProps](#101-getderivedstatefromprops)
102. [shouldComponentUpdate](#102-shouldcomponentupdate)

### 15. Context API
103. [Context API Introduction](#103-context-api-introduction)
104. [createContext](#104-createcontext)
105. [Provider](#105-provider)
106. [Consumer](#106-consumer)
107. [useContext vs Props Drilling](#107-usecontext-vs-props-drilling)

### 16. Routing
108. [React Router Introduction](#108-react-router-introduction)
109. [react-router-dom](#109-react-router-dom)
110. [BrowserRouter](#110-browserrouter)
111. [Routes & Route](#111-routes--route)
112. [Link & NavLink](#112-link--navlink)
113. [useParams](#113-useparams)
114. [useNavigate](#114-usenavigate)
115. [useLocation](#115-uselocation)
116. [Nested Routes](#116-nested-routes)
117. [Protected Routes](#117-protected-routes)
118. [404 Page Handling](#118-404-page-handling)

### 17. Data Fetching
119. [Fetch API](#119-fetch-api)
120. [Axios](#120-axios)
121. [GET Requests](#121-get-requests)
122. [POST Requests](#122-post-requests)
123. [PUT & DELETE Requests](#123-put--delete-requests)
124. [Loading States](#124-loading-states)
125. [Error Handling](#125-error-handling)
126. [API Integration Patterns](#126-api-integration-patterns)

### 18. State Management
127. [Local State](#127-local-state)
128. [Global State](#128-global-state)
129. [Redux Introduction](#129-redux-introduction)
130. [Redux Core Concepts](#130-redux-core-concepts)
131. [Store](#131-store)
132. [Actions](#132-actions)
133. [Reducers](#133-reducers)
134. [Redux Flow](#134-redux-flow)
135. [Redux Toolkit](#135-redux-toolkit)
136. [createSlice](#136-createslice)
137. [configureStore](#137-configurestore)
138. [useSelector](#138-useselector)
139. [useDispatch](#139-usedispatch)
140. [Middleware](#140-middleware)
141. [Thunk](#141-thunk)
142. [Redux vs Context API](#142-redux-vs-context-api)
143. [Zustand](#143-zustand)
144. [Recoil](#144-recoil)

### 19. Performance
145. [React.memo](#145-reactmemo)
146. [useMemo](#146-usememo)
147. [useCallback](#147-usecallback)
148. [Code Splitting](#148-code-splitting)
149. [Lazy Loading](#149-lazy-loading)
150. [React.lazy](#150-reactlazy)
151. [Suspense](#151-suspense)
152. [Avoid Re-renders](#152-avoid-re-renders)
153. [Virtualization](#153-virtualization)

### 20. Error Handling
154. [Error Boundaries](#154-error-boundaries)
155. [try-catch in React](#155-try-catch-in-react)
156. [Fallback UI](#156-fallback-ui)
157. [Logging Errors](#157-logging-errors)

### 21. Refs & DOM
158. [Refs Introduction](#158-refs-introduction)
159. [useRef](#159-useref)
160. [Forward Refs](#160-forward-refs)
161. [DOM Manipulation](#161-dom-manipulation)
162. [Focus Management](#162-focus-management)

### 22. Advanced Patterns
163. [Higher Order Components](#163-higher-order-components-hoc)
164. [Render Props](#164-render-props)
165. [Compound Components](#165-compound-components)
166. [Controlled vs Uncontrolled Patterns](#166-controlled-vs-uncontrolled-patterns)

### 23. Testing
167. [Testing Basics](#167-testing-basics)
168. [Unit Testing](#168-unit-testing)
169. [Integration Testing](#169-integration-testing)
170. [Jest](#170-jest)
171. [React Testing Library](#171-react-testing-library)
172. [Mocking APIs](#172-mocking-apis)
173. [Snapshot Testing](#173-snapshot-testing)

### 24. Security
174. [XSS in React](#174-xss-in-react)
175. [Sanitizing Inputs](#175-sanitizing-inputs)
176. [Secure API Calls](#176-secure-api-calls)
177. [Environment Variables](#177-environment-variables)

### 25. Deployment
178. [Production Build](#178-production-build)
179. [Environment Config](#179-environment-config)
180. [Hosting on Netlify](#180-hosting-on-netlify)
181. [Hosting on Vercel](#181-hosting-on-vercel)
182. [CI/CD Basics](#182-cicd-basics)

### 26. Advanced React
183. [Concurrent Rendering](#183-concurrent-rendering)
184. [React Fiber](#184-react-fiber)
185. [Suspense for Data Fetching](#185-suspense-for-data-fetching)
186. [Server Components](#186-server-components)
187. [Hydration](#187-hydration)
188. [Streaming](#188-streaming)
189. [React 18 Features](#189-react-18-features)

### 27. React + TypeScript
190. [TypeScript Basics](#190-typescript-basics)
191. [Typing Props](#191-typing-props)
192. [Typing State](#192-typing-state)
193. [Typing Hooks](#193-typing-hooks)
194. [Generics in React](#194-generics-in-react)
195. [Interfaces vs Types](#195-interfaces-vs-types)

### 28. Architecture
196. [Folder Structure Patterns](#196-folder-structure-patterns)
197. [Atomic Design](#197-atomic-design)
198. [Feature-based Structure](#198-feature-based-structure)
199. [Separation of Concerns](#199-separation-of-concerns)
200. [Clean Code Practices](#200-clean-code-practices)

### 29. Real-world Topics
201. [Props Drilling](#201-props-drilling)
202. [State Lifting](#202-state-lifting)
203. [Anti-patterns](#203-anti-patterns)
204. [Memory Leaks](#204-memory-leaks)
205. [Infinite Loops](#205-infinite-loops)
206. [Controlled Re-rendering](#206-controlled-re-rendering)
207. [Optimization Strategies](#207-optimization-strategies)
208. [Common Interview Questions](#208-common-interview-questions)

### 30. Tools
209. [ESLint](#209-eslint)
210. [Prettier](#210-prettier)
211. [Husky](#211-husky)
212. [Git Hooks](#212-git-hooks)
213. [Storybook](#213-storybook)
214. [React DevTools](#214-react-devtools)


---

Got it üëç
You want **question first, then answer** format for your repo.

## üü¢ 1. React Fundamentals

---

### **1. What is React?**

**Answer:**
React is a JavaScript library used to build user interfaces, mainly for web applications. It allows developers to create reusable UI components and build fast, interactive applications. React focuses only on the view layer (UI) and is maintained by Facebook.

React uses a component-based architecture and Virtual DOM to improve performance.

**Example**

```jsx
function App() {
  return <h1>Hello React</h1>;
}
export default App;
```

---

### **2. Why React?**

**Answer:**
React is used because it makes UI development easier, faster, and more scalable. It allows reusable components, improves performance with Virtual DOM, and has a strong ecosystem.

Key reasons:

* Reusable components
* Fast rendering
* Easy to maintain
* Large community
* Used in real-world apps

**Example**

```jsx
function Button() {
  return <button>Click me</button>;
}
```

Reuse component multiple times:

```jsx
<Button />
<Button />
```

---

### **3. History of React**

**Answer:**
React was created by Jordan Walke, a software engineer at Facebook. It was first released in 2013 as an open-source library. Facebook used it internally before releasing it publicly.

Major milestones:

* 2013: React released
* 2015: React Native
* 2019: React Hooks introduced

React became popular because of its component-based approach and performance.

---

### **4. What is a Single Page Application (SPA)?**

**Answer:**
A Single Page Application (SPA) is a web app that loads only one HTML page and dynamically updates content without reloading the page. React is commonly used to build SPAs.

Benefits:

* Fast navigation
* No full page reload
* Better user experience

**Example using React Router**

```jsx
import { BrowserRouter, Routes, Route } from "react-router-dom";

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </BrowserRouter>
  );
}
```

---

### **5. React vs Angular vs Vue**

**Answer:**
These are frontend technologies used to build web apps.

| Feature     | React   | Angular   | Vue       |
| ----------- | ------- | --------- | --------- |
| Type        | Library | Framework | Framework |
| Learning    | Easy    | Hard      | Easy      |
| Flexibility | High    | Medium    | Medium    |
| Performance | Fast    | Medium    | Fast      |

React is a library, while Angular and Vue are full frameworks.

---

### **6. What is React Architecture?**

**Answer:**
React uses a component-based architecture where the UI is broken into small reusable components. Each component manages its own logic and UI.

Structure example:

```
App
 ‚îú‚îÄ‚îÄ Header
 ‚îú‚îÄ‚îÄ Sidebar
 ‚îú‚îÄ‚îÄ Content
 ‚îî‚îÄ‚îÄ Footer
```

**Example**

```jsx
function Header() {
  return <h1>Header</h1>;
}

function App() {
  return (
    <div>
      <Header />
      <p>Main Content</p>
    </div>
  );
}
```

---

### **7. What are React Features?**

**Answer:**
React has several powerful features:

* JSX (JavaScript + HTML syntax)
* Components
* Virtual DOM
* One-way data binding
* Hooks
* Fast rendering

**Example (props)**

```jsx
function Welcome(props) {
  return <h1>Hello {props.name}</h1>;
}

<Welcome name="Adity" />
```

---

### **8. What is Virtual DOM?**

**Answer:**
Virtual DOM is a lightweight copy of the real DOM stored in memory. When state changes, React updates the virtual DOM first, compares it with the previous version, and then updates only the changed parts in the real DOM.

This makes React fast.

---

### **9. Difference between Real DOM and Virtual DOM**

**Answer:**

| Real DOM            | Virtual DOM          |
| ------------------- | -------------------- |
| Slow updates        | Fast updates         |
| Updates whole page  | Updates only changes |
| Direct manipulation | Uses diffing         |
| Heavy               | Lightweight          |

React uses Virtual DOM to improve performance.

---

### **10. What is React Reconciliation?**

**Answer:**
Reconciliation is the process where React compares the old Virtual DOM with the new Virtual DOM and updates only the changed elements in the real DOM.

This process uses a diffing algorithm.

**Example**

```jsx
import { useState } from "react";

function App() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

When count changes, only `<h1>` updates, not the whole page.

---

## üü¢ 2. Environment Setup

---

### **11. Node.js & npm basics**

**Answer:**
**Node.js** is a JavaScript runtime that allows you to run JavaScript outside the browser. It is required to run React development tools.
**npm (Node Package Manager)** is used to install libraries and dependencies.

Why needed for React:

* To install React packages
* To run development server
* To manage dependencies

**Common commands**

```bash
node -v        # check Node version
npm -v         # check npm version
npm init -y    # create package.json
npm install react
```

**Example**

```bash
npm install axios
```

This installs axios in your project.

---

### **12. What is npx?**

**Answer:**
`npx` is a tool that comes with npm and allows you to run packages without installing them globally.

It downloads and runs a package temporarily.

**Example**

```bash
npx create-react-app myapp
```

Here, you don‚Äôt need to install `create-react-app` globally.

Another example:

```bash
npx vite
```

---

### **13. What is Create React App (CRA)?**

**Answer:**
Create React App is a tool that quickly sets up a React project with all configurations (webpack, babel, etc.) already done.

It was the standard way earlier to create React apps.

**Create project**

```bash
npx create-react-app myapp
cd myapp
npm start
```

Folder structure:

```
myapp/
 ‚îú‚îÄ‚îÄ src
 ‚îú‚îÄ‚îÄ public
 ‚îú‚îÄ‚îÄ package.json
```

**Example component**

```jsx
function App() {
  return <h1>Hello CRA</h1>;
}
```

**Note:** CRA is now slowly replaced by Vite.

---

### **14. What is Vite?**

**Answer:**
Vite is a modern frontend build tool that creates React apps faster than CRA. It provides faster startup and hot reload.

Benefits:

* Very fast dev server
* Smaller bundle
* Modern setup

**Create Vite React app**

```bash
npm create vite@latest myapp
cd myapp
npm install
npm run dev
```

Select:

```
React ‚Üí JavaScript
```

**Example**

```jsx
function App() {
  return <h1>Hello Vite</h1>;
}
```

---

### **15. React Folder Structure**

**Answer:**
A good folder structure makes code maintainable.

Basic structure:

```
src/
 ‚îú‚îÄ‚îÄ components/
 ‚îú‚îÄ‚îÄ pages/
 ‚îú‚îÄ‚îÄ hooks/
 ‚îú‚îÄ‚îÄ services/
 ‚îú‚îÄ‚îÄ App.jsx
 ‚îî‚îÄ‚îÄ main.jsx
```

**Example**

```
components/
 ‚îú‚îÄ‚îÄ Navbar.jsx
 ‚îî‚îÄ‚îÄ Button.jsx
```

**Navbar component**

```jsx
function Navbar() {
  return <h1>Navbar</h1>;
}
export default Navbar;
```

---

### **16. Development vs Production build**

**Answer:**

**Development mode**

* Used while coding
* Fast reload
* Debugging enabled
* Larger bundle

Run:

```bash
npm run dev
```

**Production build**

* Optimized code
* Minified files
* Faster performance
* Used for deployment

Create production build:

```bash
npm run build
```

This creates:

```
dist/  or  build/
```

---

### **17. What is Babel?**

**Answer:**
Babel is a JavaScript compiler that converts modern JavaScript (ES6+) into browser-compatible JavaScript.

Browsers don‚Äôt understand JSX directly ‚Üí Babel converts JSX into normal JS.

**Example JSX**

```jsx
const element = <h1>Hello</h1>;
```

Babel converts to:

```js
const element = React.createElement("h1", null, "Hello");
```

Without Babel, browsers cannot run JSX.

---

### **18. Webpack basics**

**Answer:**
Webpack is a module bundler that combines all files (JS, CSS, images) into one optimized bundle.

React uses webpack internally (CRA).

What webpack does:

* Bundles files
* Optimizes code
* Handles CSS & images
* Creates production build

**Example**
Instead of loading many files:

```
app.js
style.css
image.png
```

Webpack bundles into:

```
bundle.js
```
## üü¢ 3. JSX

---

### **19. What is JSX?**

**Answer:**
JSX (JavaScript XML) is a syntax used in React that allows you to write HTML-like code inside JavaScript. It makes UI code easier to read and write. JSX is not valid JavaScript by itself ‚Äî it gets converted into normal JavaScript by Babel.

JSX allows developers to create UI elements in a declarative way.

**Example**

```jsx
function App() {
  return <h1>Hello React</h1>;
}
```

This looks like HTML but is actually JSX.
Babel converts it into:

```js
React.createElement("h1", null, "Hello React");
```

---

### **20. JSX Syntax**

**Answer:**
JSX follows rules similar to HTML but with some differences.

Rules:

* Must return one parent element
* Tags must be closed
* Use `className` instead of `class`
* Use camelCase for attributes

**Example**

```jsx
function App() {
  return (
    <div>
      <h1>Title</h1>
      <p>Paragraph</p>
    </div>
  );
}
```

Self-closing tag:

```jsx
<img src="image.png" />
```

---

### **21. JSX Expressions**

**Answer:**
JSX allows JavaScript expressions inside `{}`.
You can insert variables, functions, calculations, etc.

**Example**

```jsx
function App() {
  const name = "Adity";
  return <h1>Hello {name}</h1>;
}
```

Math expression:

```jsx
<h1>{5 + 5}</h1>
```

Function call:

```jsx
function greet() {
  return "Welcome";
}

<h1>{greet()}</h1>
```

JSX expressions cannot include:

* if statements directly
* loops directly

But you can use them outside JSX.

---

### **22. JSX Attributes**

**Answer:**
Attributes in JSX are similar to HTML but use camelCase naming.

Common differences:

| HTML    | JSX       |
| ------- | --------- |
| class   | className |
| for     | htmlFor   |
| onclick | onClick   |

**Example**

```jsx
function App() {
  return (
    <div className="container">
      <input type="text" placeholder="Enter name" />
    </div>
  );
}
```

Using dynamic value:

```jsx
const url = "image.png";
<img src={url} />
```

---

### **23. JSX Fragments**

**Answer:**
Fragments allow grouping multiple elements without adding extra DOM nodes.

Instead of:

```jsx
<div>
  <h1>Title</h1>
  <p>Text</p>
</div>
```

Use fragment:

```jsx
<>
  <h1>Title</h1>
  <p>Text</p>
</>
```

Or:

```jsx
<React.Fragment>
  <h1>Hello</h1>
</React.Fragment>
```

Fragments prevent unnecessary `<div>` in DOM.

---

### **24. JSX vs HTML**

**Answer:**

| JSX                       | HTML            |
| ------------------------- | --------------- |
| Used in React             | Used in browser |
| className used            | class used      |
| CamelCase attributes      | lowercase       |
| Must return single parent | Not required    |
| JS inside {}              | Not allowed     |

**Example**

HTML:

```html
<h1 class="title">Hello</h1>
```

JSX:

```jsx
<h1 className="title">Hello</h1>
```

---

### **25. Conditional Rendering in JSX**

**Answer:**
Conditional rendering means showing UI based on a condition.

#### Using if statement

```jsx
function App() {
  const isLogin = true;

  if (isLogin) {
    return <h1>Welcome</h1>;
  } else {
    return <h1>Please login</h1>;
  }
}
```

#### Using ternary operator

```jsx
function App() {
  const isLogin = false;

  return (
    <div>
      {isLogin ? <h1>Dashboard</h1> : <h1>Login</h1>}
    </div>
  );
}
```

#### Using &&

```jsx
{isAdmin && <p>Admin Panel</p>}
```

If condition true ‚Üí element show
If false ‚Üí nothing show

---
## üü¢ 4. Components

---

### **26. What is a Component?**

**Answer:**
A component is a reusable piece of UI in React. Components are like JavaScript functions that return JSX and define how a part of the UI should look and behave.

React apps are built by combining multiple components together.

**Example**

```jsx
function Welcome() {
  return <h1>Hello User</h1>;
}
```

Use component:

```jsx
<Welcome />
```

---

### **27. Functional Components**

**Answer:**
Functional components are simple JavaScript functions that return JSX. They are the most commonly used components in modern React.

They can use hooks like `useState` and `useEffect`.

**Example**

```jsx
function Greeting() {
  return <h1>Hello React</h1>;
}
export default Greeting;
```

With props:

```jsx
function Greeting(props) {
  return <h1>Hello {props.name}</h1>;
}

<Greeting name="Adity" />
```

---

### **28. Class Components**

**Answer:**
Class components are ES6 classes that extend `React.Component`. They were used before hooks existed. They use lifecycle methods and `this.state`.

Now mostly replaced by functional components.

**Example**

```jsx
import React, { Component } from "react";

class App extends Component {
  render() {
    return <h1>Hello Class Component</h1>;
  }
}
export default App;
```

With state:

```jsx
class Counter extends Component {
  constructor() {
    super();
    this.state = { count: 0 };
  }

  render() {
    return <h1>{this.state.count}</h1>;
  }
}
```

---

### **29. Stateless Components**

**Answer:**
Stateless components do not manage state. They only receive data via props and display UI.

**Example**

```jsx
function Title(props) {
  return <h1>{props.text}</h1>;
}
```

This component only displays data.

---

### **30. Stateful Components**

**Answer:**
Stateful components manage their own state using `useState` or class state.

**Example**

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

This component changes UI when state updates.

---

### **31. Reusable Components**

**Answer:**
Reusable components are components that can be used multiple times in different places with different data.

Benefits:

* Less code
* Easy maintenance
* Scalable

**Example**

```jsx
function Button(props) {
  return <button>{props.label}</button>;
}
```

Use multiple times:

```jsx
<Button label="Login" />
<Button label="Signup" />
```

---

### **32. Component Naming Rules**

**Answer:**
React components must follow these naming rules:

* Start with uppercase letter
* Use PascalCase
* File name should match component name

Correct:

```jsx
function Header() {}
function UserCard() {}
```

Wrong:

```jsx
function header() {}
```

Use:

```jsx
<Header />
```

---

### **33. Component Composition**

**Answer:**
Component composition means combining smaller components to create a bigger component.

This helps build complex UI using simple components.

**Example**

```jsx
function Header() {
  return <h1>Header</h1>;
}

function Footer() {
  return <h1>Footer</h1>;
}

function App() {
  return (
    <div>
      <Header />
      <p>Main content</p>
      <Footer />
    </div>
  );
}
```

Another example:

```jsx
function Card(props) {
  return (
    <div>
      <h2>{props.title}</h2>
      {props.children}
    </div>
  );
}

<Card title="Profile">
  <p>User info here</p>
</Card>
```

`props.children` allows nesting components.

---
## üü¢ 5. Props

---

### **34. Props Introduction**

**Answer:**
Props (short for *properties*) are used to pass data from one component to another in React. Props are read-only and flow in one direction: from parent ‚Üí child. They allow components to be reusable and dynamic.

**Example**

```jsx
function Welcome(props) {
  return <h1>Hello {props.name}</h1>;
}

function App() {
  return <Welcome name="Adity" />;
}
```

Here, `name` is a prop passed from `App` to `Welcome`.

---

### **35. Passing Props**

**Answer:**
Props are passed to components as attributes, similar to HTML attributes. You can pass strings, numbers, arrays, objects, and functions.

**Example**

```jsx
function User(props) {
  return (
    <div>
      <h2>{props.name}</h2>
      <p>{props.age}</p>
    </div>
  );
}

function App() {
  return <User name="Adity" age={22} />;
}
```

Passing object:

```jsx
const user = { name: "Adity", age: 22 };
<User data={user} />
```

Passing function:

```jsx
function Button(props) {
  return <button onClick={props.handleClick}>Click</button>;
}
```

---

### **36. Props Destructuring**

**Answer:**
Props destructuring is a cleaner way to extract values from props.

Instead of:

```jsx
function Welcome(props) {
  return <h1>{props.name}</h1>;
}
```

Use destructuring:

```jsx
function Welcome({ name }) {
  return <h1>{name}</h1>;
}
```

Destructuring inside component:

```jsx
function User(props) {
  const { name, age } = props;
  return <p>{name} - {age}</p>;
}
```

This makes code shorter and cleaner.

---

### **37. Default Props**

**Answer:**
Default props are used when a prop is not passed. They provide default values.

**Example**

```jsx
function Button({ label = "Click Me" }) {
  return <button>{label}</button>;
}
```

If no label passed:

```jsx
<Button />
```

Output:

```
Click Me
```

Class component default props:

```jsx
MyComponent.defaultProps = {
  name: "Guest"
};
```

---

### **38. Props Validation (PropTypes)**

**Answer:**
PropTypes help validate the type of props passed to a component. It helps catch errors during development.

Install:

```bash
npm install prop-types
```

**Example**

```jsx
import PropTypes from "prop-types";

function User({ name, age }) {
  return <h1>{name} - {age}</h1>;
}

User.propTypes = {
  name: PropTypes.string,
  age: PropTypes.number
};
```

Required prop:

```jsx
name: PropTypes.string.isRequired
```

If wrong type passed, React shows warning in console.

---

### **39. Children Props**

**Answer:**
`props.children` allows passing components or elements inside another component.

**Example**

```jsx
function Card(props) {
  return (
    <div>
      <h2>{props.title}</h2>
      {props.children}
    </div>
  );
}
```

Use:

```jsx
<Card title="Profile">
  <p>This is inside card</p>
</Card>
```

Output:

```
Profile
This is inside card
```

`children` makes components flexible.

---

### **40. Props vs State**

**Answer:**

| Props                  | State                           |
| ---------------------- | ------------------------------- |
| Passed from parent     | Managed inside component        |
| Read-only              | Can change                      |
| Used for communication | Used for dynamic UI             |
| Cannot modify directly | Updated using setState/useState |

**Props Example**

```jsx
function Welcome({ name }) {
  return <h1>{name}</h1>;
}
```

**State Example**

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);
  return <h1>{count}</h1>;
}
```

Props = external data
State = internal data

---
## üü¢ 6. State

---

### **41. What is State?**

**Answer:**
State is a built-in React object used to store data that can change over time and affect what gets rendered on the screen. When state changes, React automatically re-renders the component.

State is managed inside a component and is dynamic, unlike props which are read-only and passed from parent components.

**Example**

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return <h1>{count}</h1>;
}
```

Here, `count` is state.

---

### **42. useState Hook**

**Answer:**
`useState` is a React hook used to create and manage state in functional components.

Syntax:

```jsx
const [state, setState] = useState(initialValue);
```

* `state` ‚Üí current value
* `setState` ‚Üí function to update value

**Example**

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

Click button ‚Üí state updates ‚Üí UI re-renders.

---

### **43. Updating State**

**Answer:**
State should be updated using the setter function (`setState`). Never modify state directly.

Wrong:

```jsx
count = count + 1;
```

Correct:

```jsx
setCount(count + 1);
```

Updating based on previous state:

```jsx
setCount(prev => prev + 1);
```

Updating object state:

```jsx
const [user, setUser] = useState({ name: "Adity", age: 22 });

setUser({ ...user, age: 23 });
```

Updating array:

```jsx
setItems([...items, newItem]);
```

---

### **44. State Immutability**

**Answer:**
State in React should not be mutated directly. Instead, always create a new copy and update it.

Why?

* React detects changes by reference
* Direct mutation may not re-render component

Wrong:

```jsx
user.age = 25;
setUser(user);
```

Correct:

```jsx
setUser({ ...user, age: 25 });
```

Array example:

```jsx
setList([...list, "new item"]);
```

Immutability ensures predictable updates.

---

### **45. Lifting State Up**

**Answer:**
Lifting state up means moving state to the nearest common parent so multiple components can share it.

Used when sibling components need same data.

**Example**

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <Child1 count={count} />
      <Child2 setCount={setCount} />
    </div>
  );
}
```

Child1 shows value:

```jsx
function Child1({ count }) {
  return <h1>{count}</h1>;
}
```

Child2 updates value:

```jsx
function Child2({ setCount }) {
  return <button onClick={() => setCount(5)}>Update</button>;
}
```

State lives in parent ‚Üí shared by children.

---

### **46. Controlled Components**

**Answer:**
Controlled components are form elements whose value is controlled by React state.

React controls input value.

**Example**

```jsx
import { useState } from "react";

function Form() {
  const [name, setName] = useState("");

  return (
    <input
      value={name}
      onChange={(e) => setName(e.target.value)}
    />
  );
}
```

Here:

* input value = state
* React controls form

Benefits:

* Validation
* Dynamic UI
* Easy data handling

---

### **47. Uncontrolled Components**

**Answer:**
Uncontrolled components store data in the DOM instead of React state. We use `ref` to access values.

**Example**

```jsx
import { useRef } from "react";

function Form() {
  const inputRef = useRef();

  function handleSubmit() {
    alert(inputRef.current.value);
  }

  return (
    <div>
      <input ref={inputRef} />
      <button onClick={handleSubmit}>Submit</button>
    </div>
  );
}
```

React does not control input value directly.

---

## üìå Controlled vs Uncontrolled

| Controlled           | Uncontrolled       |
| -------------------- | ------------------ |
| Uses state           | Uses ref           |
| React controls input | DOM controls input |
| Easy validation      | Less control       |
| Recommended          | Rare use           |

---
## üü¢ 7. Event Handling

---

### **48. Handling Events in React**

**Answer:**
Event handling in React is similar to handling events in HTML/JavaScript but uses camelCase syntax and functions instead of strings.

Common events:

* onClick
* onChange
* onSubmit
* onMouseOver

**Example**

```jsx
function App() {
  function handleClick() {
    alert("Button clicked");
  }

  return <button onClick={handleClick}>Click</button>;
}
```

In React:

* Use `onClick` not `onclick`
* Pass function reference, not function call

Wrong:

```jsx
<button onClick={handleClick()}>
```

Correct:

```jsx
<button onClick={handleClick}>
```

---

### **49. Synthetic Events**

**Answer:**
React uses **Synthetic Events**, which are wrapper objects around native browser events. They provide consistent behavior across all browsers.

Instead of dealing with different browser event systems, React uses its own unified event system.

**Example**

```jsx
function App() {
  function handleClick(e) {
    console.log(e); // synthetic event
  }

  return <button onClick={handleClick}>Click</button>;
}
```

`e` is a synthetic event that works the same across browsers.

Access native event:

```jsx
e.nativeEvent
```

---

### **50. Passing Arguments to Events**

**Answer:**
Sometimes we need to pass parameters to event handlers.

**Method 1: Arrow function**

```jsx
function App() {
  function handleClick(name) {
    alert(name);
  }

  return (
    <button onClick={() => handleClick("Adity")}>
      Click
    </button>
  );
}
```

**Method 2: Bind**

```jsx
<button onClick={handleClick.bind(this, "Adity")}>
```

Arrow function is most commonly used.

---

### **51. Event Binding**

**Answer:**
Event binding means connecting event handlers to components. In functional components, binding is automatic. In class components, we must bind `this`.

**Class component example**

```jsx
class App extends React.Component {
  constructor() {
    super();
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    console.log("Clicked");
  }

  render() {
    return <button onClick={this.handleClick}>Click</button>;
  }
}
```

Alternative using arrow function:

```jsx
handleClick = () => {
  console.log("Clicked");
};
```

In functional components, binding is not needed.

---

### **52. Prevent Default**

**Answer:**
`preventDefault()` stops the default browser behavior.

Example: form submit reloads page ‚Üí prevent it.

**Example**

```jsx
function Form() {
  function handleSubmit(e) {
    e.preventDefault();
    alert("Form submitted");
  }

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">Submit</button>
    </form>
  );
}
```

Without `preventDefault`, page reloads.

---

### **53. Event Bubbling in React**

**Answer:**
Event bubbling means events propagate from child ‚Üí parent.

If a child element is clicked, parent event also triggers.

**Example**

```jsx
function App() {
  return (
    <div onClick={() => console.log("Parent clicked")}>
      <button onClick={() => console.log("Button clicked")}>
        Click
      </button>
    </div>
  );
}
```

Click button ‚Üí output:

```
Button clicked
Parent clicked
```

To stop bubbling:

```jsx
function handleClick(e) {
  e.stopPropagation();
}
```

---
## üü¢ 8. Conditional Rendering

---

### **54. if-else Rendering**

**Answer:**
In React, `if-else` is used outside JSX to render different UI based on conditions. Since JSX cannot directly contain `if` statements inside return, we use them before returning JSX.

**Example**

```jsx
function App() {
  const isLoggedIn = true;

  if (isLoggedIn) {
    return <h1>Welcome User</h1>;
  } else {
    return <h1>Please Login</h1>;
  }
}
```

This is useful when large UI blocks need conditional rendering.

---

### **55. Ternary Operator**

**Answer:**
The ternary operator allows conditional rendering directly inside JSX.

Syntax:

```
condition ? true : false
```

**Example**

```jsx
function App() {
  const isLoggedIn = false;

  return (
    <div>
      {isLoggedIn ? <h1>Dashboard</h1> : <h1>Login</h1>}
    </div>
  );
}
```

Ternary is best for simple conditions.

---

### **56. Logical AND (&&)**

**Answer:**
The `&&` operator renders content only if condition is true. If condition is false, nothing renders.

**Example**

```jsx
function App() {
  const isAdmin = true;

  return (
    <div>
      {isAdmin && <h1>Admin Panel</h1>}
    </div>
  );
}
```

If `isAdmin = false`, nothing shows.

Useful when rendering only one condition.

---

### **57. Switch Case Rendering**

**Answer:**
Switch case is useful when there are multiple conditions. Since switch cannot be used directly inside JSX, we use it in a function.

**Example**

```jsx
function Status({ status }) {
  switch (status) {
    case "loading":
      return <h1>Loading...</h1>;
    case "success":
      return <h1>Success</h1>;
    case "error":
      return <h1>Error</h1>;
    default:
      return <h1>Unknown</h1>;
  }
}
```

Use:

```jsx
<Status status="loading" />
```

---

### **58. Conditional Components**

**Answer:**
Conditional components mean rendering different components based on conditions.

**Example**

```jsx
function Login() {
  return <h1>Login Page</h1>;
}

function Dashboard() {
  return <h1>Dashboard</h1>;
}

function App() {
  const isLoggedIn = true;

  return (
    <div>
      {isLoggedIn ? <Dashboard /> : <Login />}
    </div>
  );
}
```

Another example:

```jsx
function App() {
  const role = "admin";

  if (role === "admin") {
    return <AdminPanel />;
  }

  return <UserPanel />;
}
```

---
## üü¢ 9. Lists & Keys

---

### **59. Rendering Lists**

**Answer:**
Rendering lists in React means displaying multiple items dynamically from an array. Instead of writing repeated HTML, we loop through data and generate UI elements.

React commonly uses the `map()` function to render lists.

**Example**

```jsx
function App() {
  const fruits = ["Apple", "Banana", "Mango"];

  return (
    <ul>
      {fruits.map((item) => (
        <li>{item}</li>
      ))}
    </ul>
  );
}
```

This will render:

```
Apple
Banana
Mango
```

Lists make UI dynamic and data-driven.

---

### **60. map() in JSX**

**Answer:**
The `map()` function is a JavaScript method used to iterate over arrays and return a new array. In React, it is used to generate elements from data.

Syntax:

```jsx
array.map((item, index) => JSX)
```

**Example**

```jsx
function App() {
  const users = [
    { id: 1, name: "Adity" },
    { id: 2, name: "Rahul" }
  ];

  return (
    <div>
      {users.map((user) => (
        <h1 key={user.id}>{user.name}</h1>
      ))}
    </div>
  );
}
```

Here:

* Each user becomes a JSX element
* `key` is required

---

### **61. Keys**

**Answer:**
Keys are special attributes used in lists to help React identify which items changed, added, or removed. Keys improve performance during re-rendering.

Keys must be unique.

**Example**

```jsx
const items = ["A", "B", "C"];

function App() {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}
```

Better example with unique id:

```jsx
const users = [
  { id: 1, name: "Adity" },
  { id: 2, name: "Rahul" }
];

{users.map(user => (
  <p key={user.id}>{user.name}</p>
))}
```

Why keys needed:

* Efficient updates
* Avoid unnecessary re-render
* Track elements

---

### **62. Index as Key (Anti-pattern)**

**Answer:**
Using array index as key is not recommended when list items can change order, be added, or removed. It can cause incorrect UI updates.

Bad example:

```jsx
{items.map((item, index) => (
  <li key={index}>{item}</li>
))}
```

If items reorder ‚Üí React may update wrong element.

Better:

```jsx
<li key={item.id}>{item.name}</li>
```

When index can be used:

* Static list
* No reordering
* No dynamic updates

Otherwise avoid index as key.

---

### **63. Dynamic Lists**

**Answer:**
Dynamic lists are lists that change based on user interaction or state updates.

**Example: Add item**

```jsx
import { useState } from "react";

function App() {
  const [list, setList] = useState(["Apple"]);

  function addItem() {
    setList([...list, "Mango"]);
  }

  return (
    <div>
      <button onClick={addItem}>Add</button>
      <ul>
        {list.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
}
```

**Remove item**

```jsx
function removeItem(index) {
  const newList = list.filter((_, i) => i !== index);
  setList(newList);
}
```

Dynamic lists are common in:

* Todo apps
* Product lists
* Chat apps
* Dashboards

---
## üü¢ 10. Styling in React

---

### **64. CSS in React**

**Answer:**
Styling in React can be done using normal CSS files just like traditional web development. You create a CSS file and import it into your component.

**Example**

**App.css**

```css
.title {
  color: red;
  font-size: 24px;
}
```

**App.jsx**

```jsx
import "./App.css";

function App() {
  return <h1 className="title">Hello React</h1>;
}
```

Use `className` instead of `class` in JSX.

---

### **65. Inline Styling**

**Answer:**
Inline styling in React is done using a JavaScript object inside the `style` attribute. Properties are written in camelCase.

**Example**

```jsx
function App() {
  return (
    <h1 style={{ color: "blue", fontSize: "30px" }}>
      Inline Style
    </h1>
  );
}
```

Using variable:

```jsx
const style = {
  color: "green",
  backgroundColor: "black"
};

<h1 style={style}>Hello</h1>
```

Inline styles are useful for dynamic styling but not recommended for large styling.

---

### **66. CSS Modules**

**Answer:**
CSS Modules allow scoped CSS. Styles apply only to the component, preventing global conflicts.

Create file:

```
Button.module.css
```

**Button.module.css**

```css
.btn {
  background: blue;
  color: white;
}
```

**Button.jsx**

```jsx
import styles from "./Button.module.css";

function Button() {
  return <button className={styles.btn}>Click</button>;
}
```

Class names become unique automatically.

---

### **67. Styled Components**

**Answer:**
Styled Components is a library that allows writing CSS inside JavaScript using tagged template literals.

Install:

```bash
npm install styled-components
```

**Example**

```jsx
import styled from "styled-components";

const Button = styled.button`
  background: red;
  color: white;
  padding: 10px;
`;

function App() {
  return <Button>Click</Button>;
}
```

Benefits:

* Scoped styles
* Dynamic styling
* Cleaner components

Dynamic example:

```jsx
const Button = styled.button`
  background: ${props => props.primary ? "blue" : "gray"};
`;
```

---

### **68. SCSS / SASS**

**Answer:**
SCSS/SASS is a CSS preprocessor that adds features like variables, nesting, and mixins.

Install:

```bash
npm install sass
```

**Example**

```scss
$primary: red;

.title {
  color: $primary;
}
```

**App.jsx**

```jsx
import "./style.scss";

function App() {
  return <h1 className="title">SCSS Style</h1>;
}
```

SCSS helps organize large CSS code.

---

### **69. Tailwind CSS**

**Answer:**
Tailwind CSS is a utility-first CSS framework where styles are applied using classes directly in JSX.

Install (Vite example):

```bash
npm install -D tailwindcss
npx tailwindcss init
```

**Example**

```jsx
function App() {
  return (
    <h1 className="text-red-500 text-3xl font-bold">
      Tailwind Style
    </h1>
  );
}
```

Benefits:

* Fast styling
* No custom CSS needed
* Responsive utilities

---

### **70. Dynamic Styles**

**Answer:**
Dynamic styling means changing styles based on state or props.

**Example using state**

```jsx
import { useState } from "react";

function App() {
  const [dark, setDark] = useState(false);

  return (
    <div>
      <button onClick={() => setDark(!dark)}>Toggle</button>
      <h1 style={{ color: dark ? "white" : "black" }}>
        Dynamic Style
      </h1>
    </div>
  );
}
```

Using class condition:

```jsx
<h1 className={dark ? "dark" : "light"}>Text</h1>
```

Dynamic styling is used for:

* Dark mode
* Active buttons
* Theme switching

---
## üü¢ 11. Forms

---

### **71. Forms in React**

**Answer:**
Forms in React are used to collect user input such as text, email, password, etc. React forms work differently from traditional HTML forms because React usually controls the form using state.

When a user types in an input field, React state updates and UI reflects changes.

**Example**

```jsx
function App() {
  return (
    <form>
      <input type="text" placeholder="Enter name" />
      <button>Submit</button>
    </form>
  );
}
```

In real apps, React state is used to manage form data.

---

### **72. Controlled Forms**

**Answer:**
Controlled forms are forms where React controls the input value using state. The value of input is stored in state and updated using `onChange`.

This is the recommended approach in React.

**Example**

```jsx
import { useState } from "react";

function Form() {
  const [name, setName] = useState("");

  return (
    <input
      type="text"
      value={name}
      onChange={(e) => setName(e.target.value)}
    />
  );
}
```

Form submit example:

```jsx
function Form() {
  const [name, setName] = useState("");

  function handleSubmit(e) {
    e.preventDefault();
    console.log(name);
  }

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
      <button>Submit</button>
    </form>
  );
}
```

React controls the form completely.

---

### **73. Uncontrolled Forms**

**Answer:**
Uncontrolled forms store input data in the DOM instead of React state. We use `useRef` to access values.

Less commonly used.

**Example**

```jsx
import { useRef } from "react";

function Form() {
  const inputRef = useRef();

  function handleSubmit(e) {
    e.preventDefault();
    console.log(inputRef.current.value);
  }

  return (
    <form onSubmit={handleSubmit}>
      <input ref={inputRef} />
      <button>Submit</button>
    </form>
  );
}
```

Here React does not control the input value.

---

### **74. Form Validation**

**Answer:**
Form validation ensures user inputs correct data.

Types:

* Required field
* Email format
* Password length

**Example**

```jsx
import { useState } from "react";

function Form() {
  const [email, setEmail] = useState("");
  const [error, setError] = useState("");

  function handleSubmit(e) {
    e.preventDefault();

    if (!email.includes("@")) {
      setError("Invalid email");
    } else {
      setError("");
      alert("Submitted");
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <p>{error}</p>
      <button>Submit</button>
    </form>
  );
}
```

Libraries:

* Formik
* React Hook Form
* Yup

---

### **75. Multiple Inputs**

**Answer:**
When a form has multiple fields, we store them in one state object.

**Example**

```jsx
import { useState } from "react";

function Form() {
  const [form, setForm] = useState({
    name: "",
    email: ""
  });

  function handleChange(e) {
    setForm({
      ...form,
      [e.target.name]: e.target.value
    });
  }

  return (
    <form>
      <input
        name="name"
        value={form.name}
        onChange={handleChange}
      />
      <input
        name="email"
        value={form.email}
        onChange={handleChange}
      />
    </form>
  );
}
```

This handles multiple inputs with one function.

---

### **76. Handling Checkbox & Radio**

**Answer:**

#### Checkbox

```jsx
import { useState } from "react";

function App() {
  const [checked, setChecked] = useState(false);

  return (
    <input
      type="checkbox"
      checked={checked}
      onChange={(e) => setChecked(e.target.checked)}
    />
  );
}
```

#### Radio buttons

```jsx
function App() {
  const [gender, setGender] = useState("");

  return (
    <div>
      <input
        type="radio"
        value="male"
        onChange={(e) => setGender(e.target.value)}
      /> Male

      <input
        type="radio"
        value="female"
        onChange={(e) => setGender(e.target.value)}
      /> Female
    </div>
  );
}
```

---

### **77. Select Dropdown**

**Answer:**
Select dropdown is controlled using state.

**Example**

```jsx
import { useState } from "react";

function App() {
  const [city, setCity] = useState("");

  return (
    <select
      value={city}
      onChange={(e) => setCity(e.target.value)}
    >
      <option value="">Select</option>
      <option value="Delhi">Delhi</option>
      <option value="Mumbai">Mumbai</option>
    </select>
  );
}
```

Multiple select:

```jsx
<select multiple>
```

---
## üü¢ 12. Hooks (Core)

---

### **78. What are Hooks?**

**Answer:**
Hooks are special functions in React that allow functional components to use state and lifecycle features. Before hooks, only class components could manage state and lifecycle. Hooks made functional components more powerful.

Common hooks:

* useState
* useEffect
* useRef
* useMemo
* useCallback

Hooks were introduced in React 16.8.

**Example**

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return <h1>{count}</h1>;
}
```

Here, `useState` is a hook.

---

### **79. Rules of Hooks**

**Answer:**
Hooks must follow specific rules:

1. Only call hooks at the top level
2. Do not call hooks inside loops or conditions
3. Only call hooks inside React functions
4. Use hooks inside functional components or custom hooks

Wrong:

```jsx
if (true) {
  useState(0);
}
```

Correct:

```jsx
const [count, setCount] = useState(0);
```

React relies on hook order, so rules are important.

---

### **80. useState**

**Answer:**
`useState` is used to manage state in functional components.

Syntax:

```jsx
const [state, setState] = useState(initialValue);
```

**Example**

```jsx
import { useState } from "react";

function App() {
  const [name, setName] = useState("");

  return (
    <div>
      <input onChange={(e) => setName(e.target.value)} />
      <h1>{name}</h1>
    </div>
  );
}
```

Updating state:

```jsx
setName("Adity");
```

---

### **81. useEffect**

**Answer:**
`useEffect` is used for side effects such as:

* API calls
* timers
* DOM updates
* subscriptions

It runs after the component renders.

Syntax:

```jsx
useEffect(() => {
  // code
});
```

Runs on every render.

**Example**

```jsx
import { useEffect } from "react";

function App() {
  useEffect(() => {
    console.log("Component rendered");
  });

  return <h1>Hello</h1>;
}
```

---

### **82. useEffect Cleanup**

**Answer:**
Cleanup function runs when component unmounts or before effect runs again. Used to remove event listeners, timers, etc.

**Example**

```jsx
import { useEffect } from "react";

function App() {
  useEffect(() => {
    const interval = setInterval(() => {
      console.log("Running");
    }, 1000);

    return () => {
      clearInterval(interval);
    };
  }, []);

  return <h1>Timer</h1>;
}
```

Cleanup prevents memory leaks.

---

### **83. Dependency Array**

**Answer:**
Dependency array controls when `useEffect` runs.

#### Run once (on mount)

```jsx
useEffect(() => {
  console.log("Run once");
}, []);
```

#### Run when value changes

```jsx
useEffect(() => {
  console.log("Count changed");
}, [count]);
```

#### Run on every render

```jsx
useEffect(() => {
  console.log("Every render");
});
```

Dependency array improves performance.

---

### **84. Multiple useEffect**

**Answer:**
You can use multiple `useEffect` hooks in one component. Each handles separate logic.

**Example**

```jsx
import { useEffect, useState } from "react";

function App() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Component mounted");
  }, []);

  useEffect(() => {
    console.log("Count updated");
  }, [count]);

  return (
    <button onClick={() => setCount(count + 1)}>
      {count}
    </button>
  );
}
```

Benefits:

* Separate logic
* Clean code
* Better organization

---
## üü¢ 13. Hooks (Advanced)

---

### **85. useContext**

**Answer:**
`useContext` is a React hook used to access data from the Context API without passing props manually through every component (props drilling). It allows global data sharing like theme, user info, language, etc.

**Example**

```jsx
import { createContext, useContext } from "react";

const ThemeContext = createContext();

function Child() {
  const theme = useContext(ThemeContext);
  return <h1>{theme}</h1>;
}

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Child />
    </ThemeContext.Provider>
  );
}
```

Here `Child` directly accesses context value.

---

### **86. Context API**

**Answer:**
Context API allows sharing data globally across components without passing props at every level.

Steps:

1. Create context
2. Provide value
3. Consume value

**Example**

```jsx
import { createContext } from "react";

export const UserContext = createContext();
```

Provide:

```jsx
<UserContext.Provider value="Adity">
  <App />
</UserContext.Provider>
```

Consume:

```jsx
import { useContext } from "react";
import { UserContext } from "./UserContext";

function Profile() {
  const user = useContext(UserContext);
  return <h1>{user}</h1>;
}
```

Used for:

* Auth data
* Theme
* Global state

---

### **87. useReducer**

**Answer:**
`useReducer` is used for complex state logic. It works like Redux reducer.

Syntax:

```jsx
const [state, dispatch] = useReducer(reducer, initialState);
```

**Example**

```jsx
import { useReducer } from "react";

function reducer(state, action) {
  if (action.type === "increment") {
    return { count: state.count + 1 };
  }
  return state;
}

function App() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <button onClick={() => dispatch({ type: "increment" })}>
      {state.count}
    </button>
  );
}
```

Best for:

* Complex state
* Multiple actions
* Large apps

---

### **88. useRef**

**Answer:**
`useRef` is used to:

* Access DOM elements
* Store values without re-render

**Example (DOM access)**

```jsx
import { useRef } from "react";

function App() {
  const inputRef = useRef();

  function focusInput() {
    inputRef.current.focus();
  }

  return (
    <div>
      <input ref={inputRef} />
      <button onClick={focusInput}>Focus</button>
    </div>
  );
}
```

Store value without re-render:

```jsx
const countRef = useRef(0);
countRef.current++;
```

---

### **89. useImperativeHandle**

**Answer:**
`useImperativeHandle` is used with `forwardRef` to customize what parent can access from child component.

Used in advanced scenarios.

**Example**

```jsx
import { useRef, forwardRef, useImperativeHandle } from "react";

const Input = forwardRef((props, ref) => {
  const inputRef = useRef();

  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current.focus()
  }));

  return <input ref={inputRef} />;
});

function App() {
  const ref = useRef();

  return (
    <div>
      <Input ref={ref} />
      <button onClick={() => ref.current.focus()}>
        Focus
      </button>
    </div>
  );
}
```

---

### **90. useLayoutEffect**

**Answer:**
`useLayoutEffect` works like `useEffect` but runs synchronously after DOM updates and before browser paints.

Used when DOM measurement needed.

**Example**

```jsx
import { useLayoutEffect, useRef } from "react";

function App() {
  const ref = useRef();

  useLayoutEffect(() => {
    console.log(ref.current.offsetHeight);
  }, []);

  return <div ref={ref}>Hello</div>;
}
```

Difference:

* useEffect ‚Üí after paint
* useLayoutEffect ‚Üí before paint

---

### **91. useCallback**

**Answer:**
`useCallback` memoizes functions so they are not recreated on every render. Useful for performance optimization.

Syntax:

```jsx
const memoFn = useCallback(fn, dependencies);
```

**Example**

```jsx
import { useCallback, useState } from "react";

function App() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    console.log("Clicked");
  }, []);

  return <button onClick={handleClick}>{count}</button>;
}
```

Prevents unnecessary re-renders.

---

### **92. useMemo**

**Answer:**
`useMemo` memoizes computed values to avoid expensive calculations on every render.

Syntax:

```jsx
const value = useMemo(() => compute, [deps]);
```

**Example**

```jsx
import { useMemo, useState } from "react";

function App() {
  const [count, setCount] = useState(0);

  const expensive = useMemo(() => {
    console.log("Calculating...");
    return count * 2;
  }, [count]);

  return <h1>{expensive}</h1>;
}
```

Runs calculation only when dependency changes.

---

### **93. Custom Hooks**

**Answer:**
Custom hooks are user-defined hooks that reuse logic across components. They start with `use`.

**Example**

```jsx
import { useState, useEffect } from "react";

function useFetch(url) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(data => setData(data));
  }, [url]);

  return data;
}
```

Use custom hook:

```jsx
function App() {
  const data = useFetch("https://api.com");
  return <div>{JSON.stringify(data)}</div>;
}
```

Benefits:

* Reusable logic
* Clean code
* Better structure

---
## üü¢ 14. Lifecycle Methods (Class)

---

### **94. Component Lifecycle**

**Answer:**
In class components, lifecycle methods are special methods that run at different stages of a component‚Äôs life. These stages are:

1. Mounting (component created and added to DOM)
2. Updating (when state or props change)
3. Unmounting (component removed from DOM)

Lifecycle methods allow us to run code at these stages (API calls, cleanup, etc.).

---

### **95. Mounting Phase**

**Answer:**
Mounting phase happens when a component is created and inserted into the DOM.

Order of mounting methods:

1. constructor()
2. getDerivedStateFromProps()
3. render()
4. componentDidMount()

**Example**

```jsx
class App extends React.Component {
  componentDidMount() {
    console.log("Component mounted");
  }

  render() {
    return <h1>Hello</h1>;
  }
}
```

Used for:

* API calls
* timers
* subscriptions

---

### **96. Updating Phase**

**Answer:**
Updating phase occurs when state or props change.

Order:

1. getDerivedStateFromProps()
2. shouldComponentUpdate()
3. render()
4. componentDidUpdate()

**Example**

```jsx
class App extends React.Component {
  componentDidUpdate() {
    console.log("Updated");
  }

  render() {
    return <h1>Update</h1>;
  }
}
```

Used for:

* reacting to prop changes
* API calls on update

---

### **97. Unmounting Phase**

**Answer:**
Unmounting happens when component is removed from DOM.

Method:

* componentWillUnmount()

Used to clean up:

* timers
* event listeners
* subscriptions

**Example**

```jsx
class App extends React.Component {
  componentWillUnmount() {
    console.log("Component removed");
  }

  render() {
    return <h1>Unmount</h1>;
  }
}
```

---

### **98. componentDidMount**

**Answer:**
Runs once after component is mounted. Best place for API calls and setup.

**Example**

```jsx
class App extends React.Component {
  componentDidMount() {
    console.log("API call here");
  }

  render() {
    return <h1>Hello</h1>;
  }
}
```

Equivalent hook:

```jsx
useEffect(() => {}, []);
```

---

### **99. componentDidUpdate**

**Answer:**
Runs after component updates due to state or props change.

**Example**

```jsx
class App extends React.Component {
  componentDidUpdate(prevProps, prevState) {
    console.log("Component updated");
  }

  render() {
    return <h1>Update</h1>;
  }
}
```

Use case:

* fetch new data when prop changes

---

### **100. componentWillUnmount**

**Answer:**
Runs before component is removed from DOM. Used for cleanup.

**Example**

```jsx
class App extends React.Component {
  componentWillUnmount() {
    console.log("Cleanup");
  }

  render() {
    return <h1>Bye</h1>;
  }
}
```

Cleanup example:

```jsx
componentWillUnmount() {
  clearInterval(this.timer);
}
```

Equivalent hook:

```jsx
useEffect(() => {
  return () => {};
}, []);
```

---

### **101. getDerivedStateFromProps**

**Answer:**
This static method runs before rendering when props change. It updates state based on props.

Rarely used.

**Example**

```jsx
class App extends React.Component {
  static getDerivedStateFromProps(props, state) {
    if (props.value !== state.value) {
      return { value: props.value };
    }
    return null;
  }

  render() {
    return <h1>{this.state.value}</h1>;
  }
}
```

Use carefully ‚Äî often avoid.

---

### **102. shouldComponentUpdate**

**Answer:**
This method decides whether component should re-render or not. Used for performance optimization.

Return:

* true ‚Üí re-render
* false ‚Üí skip render

**Example**

```jsx
class App extends React.Component {
  shouldComponentUpdate(nextProps) {
    if (nextProps.value !== this.props.value) {
      return true;
    }
    return false;
  }

  render() {
    return <h1>{this.props.value}</h1>;
  }
}
```

Helps avoid unnecessary renders.

Equivalent:

* React.memo
* useMemo

---

## üìå Lifecycle Summary

**Mount**

* constructor
* render
* componentDidMount

**Update**

* shouldComponentUpdate
* componentDidUpdate

**Unmount**

* componentWillUnmount

---
## üü¢ 15. Context API

---

### **103. Context API Introduction**

**Answer:**
Context API is a built-in React feature that allows you to share data globally across components without passing props manually through every level (props drilling).

It is commonly used for:

* Authentication data
* Theme (dark/light mode)
* Language settings
* Global state

Without context:

```
App ‚Üí Parent ‚Üí Child ‚Üí GrandChild
```

Props must pass through each component.

With context:

```
App ‚Üí Context ‚Üí Any component can access directly
```

Context makes state sharing easier.

---

### **104. createContext**

**Answer:**
`createContext` is used to create a context object. It returns a Provider and Consumer.

**Example**

```jsx
import { createContext } from "react";

const UserContext = createContext();
```

You can also give default value:

```jsx
const UserContext = createContext("Guest");
```

This context will be used to share data.

---

### **105. Provider**

**Answer:**
Provider is used to wrap components and provide data to all child components.

**Example**

```jsx
import { createContext } from "react";

export const UserContext = createContext();

function App() {
  return (
    <UserContext.Provider value="Adity">
      <Profile />
    </UserContext.Provider>
  );
}
```

Now all components inside Provider can access `"Adity"`.

Provider passes data globally.

---

### **106. Consumer**

**Answer:**
Consumer is used to access context data. It was used before `useContext` hook.

**Example**

```jsx
<UserContext.Consumer>
  {(value) => <h1>{value}</h1>}
</UserContext.Consumer>
```

Full example:

```jsx
function Profile() {
  return (
    <UserContext.Consumer>
      {(user) => <h1>{user}</h1>}
    </UserContext.Consumer>
  );
}
```

Today, `useContext` hook is preferred over Consumer.

---

### **107. useContext vs Props Drilling**

**Answer:**

**Props Drilling:**
Passing props through multiple components just to reach a deeply nested component.

Example:

```jsx
<App user="Adity" />
```

App ‚Üí Parent ‚Üí Child ‚Üí Profile
All components must pass `user`.

**Context Solution**

```jsx
const UserContext = createContext();

function App() {
  return (
    <UserContext.Provider value="Adity">
      <Profile />
    </UserContext.Provider>
  );
}
```

Access:

```jsx
import { useContext } from "react";

function Profile() {
  const user = useContext(UserContext);
  return <h1>{user}</h1>;
}
```

---

### **Props vs Context**

| Props               | Context              |
| ------------------- | -------------------- |
| Passed manually     | Global access        |
| Good for small data | Good for global data |
| Simple apps         | Large apps           |

---

### **When to use Context**

Use when:

* Many components need same data
* Avoid props drilling
* Global settings

Avoid when:

* Frequent updates
* Very large state (use Redux/Zustand)

---
## üü¢ 16. Routing

---

### **108. React Router Introduction**

**Answer:**
React Router is a library used to handle navigation in React single-page applications (SPA). It allows switching between pages without reloading the browser.

Instead of loading new HTML pages, React dynamically renders components based on URL.

Example:

```
/home
/about
/contact
```

Each URL renders a different component.

---

### **109. react-router-dom**

**Answer:**
`react-router-dom` is the package used for routing in web React apps.

Install:

```bash
npm install react-router-dom
```

It provides:

* BrowserRouter
* Routes
* Route
* Link
* useNavigate
* useParams

---

### **110. BrowserRouter**

**Answer:**
`BrowserRouter` wraps the entire app and enables routing using browser history API.

**Example**

```jsx
import { BrowserRouter } from "react-router-dom";

function App() {
  return (
    <BrowserRouter>
      <h1>My App</h1>
    </BrowserRouter>
  );
}
```

All routes must be inside BrowserRouter.

---

### **111. Routes & Route**

**Answer:**
`Routes` contains multiple `Route` components.
Each `Route` maps a path to a component.

**Example**

```jsx
import { Routes, Route } from "react-router-dom";

function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/about" element={<About />} />
    </Routes>
  );
}
```

When user visits `/about` ‚Üí About component shows.

---

### **112. Link & NavLink**

**Answer:**
`Link` is used for navigation without page reload.
`NavLink` is similar but adds active class.

**Link example**

```jsx
import { Link } from "react-router-dom";

<Link to="/about">About</Link>
```

**NavLink example**

```jsx
import { NavLink } from "react-router-dom";

<NavLink to="/about">About</NavLink>
```

Active styling:

```jsx
<NavLink
  to="/about"
  className={({ isActive }) => (isActive ? "active" : "")}
>
  About
</NavLink>
```

---

### **113. useParams**

**Answer:**
`useParams` is used to get dynamic URL parameters.

URL:

```
/user/5
```

Route:

```jsx
<Route path="/user/:id" element={<User />} />
```

Component:

```jsx
import { useParams } from "react-router-dom";

function User() {
  const { id } = useParams();
  return <h1>User {id}</h1>;
}
```

---

### **114. useNavigate**

**Answer:**
`useNavigate` is used for programmatic navigation.

**Example**

```jsx
import { useNavigate } from "react-router-dom";

function App() {
  const navigate = useNavigate();

  return (
    <button onClick={() => navigate("/about")}>
      Go About
    </button>
  );
}
```

Navigate back:

```jsx
navigate(-1);
```

---

### **115. useLocation**

**Answer:**
`useLocation` returns current URL info like pathname and state.

**Example**

```jsx
import { useLocation } from "react-router-dom";

function App() {
  const location = useLocation();
  console.log(location.pathname);
}
```

Passing state:

```jsx
navigate("/about", { state: { name: "Adity" } });
```

Access:

```jsx
const location = useLocation();
console.log(location.state.name);
```

---

### **116. Nested Routes**

**Answer:**
Nested routes allow rendering child routes inside parent component.

**Example**

```jsx
<Route path="/dashboard" element={<Dashboard />}>
  <Route path="profile" element={<Profile />} />
</Route>
```

Dashboard.jsx:

```jsx
import { Outlet } from "react-router-dom";

function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <Outlet />
    </div>
  );
}
```

URL:

```
/dashboard/profile
```

---

### **117. Protected Routes**

**Answer:**
Protected routes restrict access to logged-in users.

**Example**

```jsx
function ProtectedRoute({ children }) {
  const isAuth = true;

  return isAuth ? children : <Navigate to="/login" />;
}
```

Use:

```jsx
<Route
  path="/dashboard"
  element={
    <ProtectedRoute>
      <Dashboard />
    </ProtectedRoute>
  }
/>
```

---

### **118. 404 Page Handling**

**Answer:**
When route not found, show 404 page using `*`.

**Example**

```jsx
<Route path="*" element={<NotFound />} />
```

NotFound component:

```jsx
function NotFound() {
  return <h1>404 Page Not Found</h1>;
}
```

This catches all invalid URLs.

---
## üü¢ 17. Data Fetching

---

### **119. Fetch API**

**Answer:**
Fetch API is a built-in JavaScript method used to make HTTP requests (GET, POST, etc.). It returns a Promise and is commonly used inside `useEffect` in React.

**Example (GET request)**

```jsx
import { useEffect, useState } from "react";

function App() {
  const [data, setData] = useState([]);

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/posts")
      .then(res => res.json())
      .then(data => setData(data));
  }, []);

  return (
    <div>
      {data.map(item => (
        <p key={item.id}>{item.title}</p>
      ))}
    </div>
  );
}
```

Fetch steps:

1. fetch URL
2. convert to JSON
3. store in state

---

### **120. Axios**

**Answer:**
Axios is a popular library for making HTTP requests. It is easier and more powerful than fetch.

Install:

```bash
npm install axios
```

**Example**

```jsx
import axios from "axios";
import { useEffect, useState } from "react";

function App() {
  const [data, setData] = useState([]);

  useEffect(() => {
    axios.get("https://jsonplaceholder.typicode.com/posts")
      .then(res => setData(res.data));
  }, []);

  return (
    <div>
      {data.map(item => (
        <p key={item.id}>{item.title}</p>
      ))}
    </div>
  );
}
```

Axios advantages:

* Auto JSON parsing
* Error handling
* Interceptors
* Short syntax

---

### **121. GET Requests**

**Answer:**
GET request is used to fetch data from server.

**Fetch example**

```jsx
useEffect(() => {
  fetch("/api/users")
    .then(res => res.json())
    .then(data => setUsers(data));
}, []);
```

**Axios example**

```jsx
useEffect(() => {
  axios.get("/api/users")
    .then(res => setUsers(res.data));
}, []);
```

GET is used for:

* fetching products
* user list
* posts

---

### **122. POST Requests**

**Answer:**
POST request is used to send data to server (create data).

**Fetch example**

```jsx
fetch("/api/users", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ name: "Adity" })
});
```

**Axios example**

```jsx
axios.post("/api/users", {
  name: "Adity"
});
```

Used for:

* login
* signup
* form submission

---

### **123. PUT & DELETE Requests**

**Answer:**

**PUT (update data)**

```jsx
axios.put("/api/users/1", {
  name: "New Name"
});
```

**DELETE**

```jsx
axios.delete("/api/users/1");
```

Fetch example:

```jsx
fetch("/api/users/1", { method: "DELETE" });
```

Used for:

* updating profile
* deleting items

---

### **124. Loading States**

**Answer:**
Loading state shows loader while API is fetching data.

**Example**

```jsx
import { useState, useEffect } from "react";
import axios from "axios";

function App() {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    axios.get("/api/posts")
      .then(res => setData(res.data))
      .finally(() => setLoading(false));
  }, []);

  if (loading) return <h1>Loading...</h1>;

  return <div>{data.length} items</div>;
}
```

---

### **125. Error Handling**

**Answer:**
Handle errors when API fails.

**Axios example**

```jsx
const [error, setError] = useState("");

useEffect(() => {
  axios.get("/api/posts")
    .then(res => setData(res.data))
    .catch(err => setError("Failed to load"));
}, []);
```

Show error:

```jsx
{error && <p>{error}</p>}
```

Fetch example:

```jsx
fetch("/api")
  .then(res => {
    if (!res.ok) throw new Error("Error");
    return res.json();
  })
  .catch(err => console.log(err));
```

---

### **126. API Integration Patterns**

**Answer:**
Common patterns for API integration:

#### 1. useEffect + useState pattern

```jsx
useEffect(() => {
  axios.get("/api").then(res => setData(res.data));
}, []);
```

#### 2. Custom hook pattern

```jsx
function useFetch(url) {
  const [data, setData] = useState([]);

  useEffect(() => {
    axios.get(url).then(res => setData(res.data));
  }, [url]);

  return data;
}
```

Use:

```jsx
const users = useFetch("/api/users");
```

#### 3. Central API file

```
api.js
```

```js
import axios from "axios";

export const api = axios.create({
  baseURL: "https://api.com"
});
```

Use:

```jsx
api.get("/users");
```

#### 4. Async/await pattern

```jsx
useEffect(() => {
  async function fetchData() {
    const res = await axios.get("/api");
    setData(res.data);
  }
  fetchData();
}, []);
```

---
## üü¢ 18. State Management

---

### **127. Local State**

**Answer:**
Local state is state managed inside a single component using hooks like `useState`. It is used when data is only needed within that component.

**Example**

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      {count}
    </button>
  );
}
```

Local state is simple and used for:

* form inputs
* toggles
* small UI states

---

### **128. Global State**

**Answer:**
Global state is data shared across multiple components. Instead of passing props manually, global state can be accessed anywhere.

Used for:

* user authentication
* theme
* cart data

Global state tools:

* Context API
* Redux
* Zustand
* Recoil

---

### **129. Redux Introduction**

**Answer:**
Redux is a state management library used to manage global state in large React applications. It stores state in a central store and components can access/update it.

Redux follows predictable state flow.

Install:

```bash
npm install redux react-redux
```

---

### **130. Redux Core Concepts**

**Answer:**
Redux has three main concepts:

1. Store ‚Üí holds state
2. Actions ‚Üí describe changes
3. Reducer ‚Üí updates state

Flow:

```
Component ‚Üí dispatch action ‚Üí reducer ‚Üí store ‚Üí UI updates
```

---

### **131. Store**

**Answer:**
Store is the central place where all state is stored.

**Example**

```js
import { createStore } from "redux";

const store = createStore(reducer);
```

In Redux Toolkit:

```js
import { configureStore } from "@reduxjs/toolkit";

const store = configureStore({
  reducer: counterReducer
});
```

---

### **132. Actions**

**Answer:**
Actions are objects that describe what happened.

Example:

```js
{ type: "increment" }
```

With payload:

```js
{ type: "add", payload: 5 }
```

Actions are dispatched to update state.

---

### **133. Reducers**

**Answer:**
Reducer is a function that updates state based on action.

**Example**

```js
function reducer(state = { count: 0 }, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    default:
      return state;
  }
}
```

Reducers must be pure functions.

---

### **134. Redux Flow**

**Answer:**
Redux data flow:

1. User clicks button
2. dispatch(action)
3. reducer runs
4. store updates
5. UI re-renders

**Example**

```jsx
dispatch({ type: "increment" });
```

---

### **135. Redux Toolkit**

**Answer:**
Redux Toolkit is the modern way to write Redux. It reduces boilerplate and simplifies setup.

Install:

```bash
npm install @reduxjs/toolkit react-redux
```

Benefits:

* Less code
* Built-in devtools
* Async support

---

### **136. createSlice**

**Answer:**
`createSlice` creates reducer + actions together.

**Example**

```js
import { createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: { count: 0 },
  reducers: {
    increment: (state) => {
      state.count++;
    }
  }
});

export const { increment } = counterSlice.actions;
export default counterSlice.reducer;
```

---

### **137. configureStore**

**Answer:**
`configureStore` creates Redux store easily.

**Example**

```js
import { configureStore } from "@reduxjs/toolkit";
import counterReducer from "./slice";

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
});
```

Wrap app:

```jsx
import { Provider } from "react-redux";
import { store } from "./store";

<Provider store={store}>
  <App />
</Provider>
```

---

### **138. useSelector**

**Answer:**
`useSelector` reads data from store.

**Example**

```jsx
import { useSelector } from "react-redux";

function Counter() {
  const count = useSelector(state => state.counter.count);
  return <h1>{count}</h1>;
}
```

---

### **139. useDispatch**

**Answer:**
`useDispatch` sends actions to store.

**Example**

```jsx
import { useDispatch } from "react-redux";
import { increment } from "./slice";

function Counter() {
  const dispatch = useDispatch();

  return (
    <button onClick={() => dispatch(increment())}>
      Add
    </button>
  );
}
```

---

### **140. Middleware**

**Answer:**
Middleware runs between dispatch and reducer. Used for logging, async calls, etc.

Examples:

* redux-thunk
* logger

---

### **141. Thunk**

**Answer:**
Redux Thunk allows async actions like API calls.

**Example**

```js
export const fetchData = () => async (dispatch) => {
  const res = await fetch("/api");
  const data = await res.json();

  dispatch(setData(data));
};
```

Dispatch:

```jsx
dispatch(fetchData());
```

---

### **142. Redux vs Context API**

| Redux      | Context       |
| ---------- | ------------- |
| Large apps | Small apps    |
| Powerful   | Simple        |
| Middleware | No middleware |
| DevTools   | Basic         |

Use Redux when:

* complex state
* large apps

---

### **143. Zustand**

**Answer:**
Zustand is a lightweight state management library. Very simple compared to Redux.

Install:

```bash
npm install zustand
```

**Example**

```js
import { create } from "zustand";

const useStore = create((set) => ({
  count: 0,
  inc: () => set(state => ({ count: state.count + 1 }))
}));
```

Use:

```jsx
const count = useStore(state => state.count);
```

---

### **144. Recoil**

**Answer:**
Recoil is a state management library by Facebook. It manages global state using atoms and selectors.

Install:

```bash
npm install recoil
```

**Example**

```jsx
import { atom, useRecoilState } from "recoil";

const countState = atom({
  key: "count",
  default: 0
});

function Counter() {
  const [count, setCount] = useRecoilState(countState);

  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

---
## üü¢ 19. Performance Optimization

---

### **145. React.memo**

**Answer:**
`React.memo` is a higher-order component used to prevent unnecessary re-rendering of functional components. It only re-renders the component if props change.

**Example**

```jsx
import React from "react";

const Child = React.memo(function Child({ name }) {
  console.log("Child rendered");
  return <h1>{name}</h1>;
});

function App() {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <Child name="Adity" />
      <button onClick={() => setCount(count + 1)}>
        {count}
      </button>
    </div>
  );
}
```

Here, `Child` will not re-render when `count` changes because props remain same.

---

### **146. useMemo**

**Answer:**
`useMemo` is used to memoize expensive calculations so they don‚Äôt run on every render.

Syntax:

```jsx
const value = useMemo(() => calculation, [dependencies]);
```

**Example**

```jsx
import { useMemo, useState } from "react";

function App() {
  const [count, setCount] = useState(0);

  const double = useMemo(() => {
    console.log("Calculating...");
    return count * 2;
  }, [count]);

  return <h1>{double}</h1>;
}
```

Calculation runs only when `count` changes.

---

### **147. useCallback**

**Answer:**
`useCallback` memoizes functions so they are not recreated on each render. Useful when passing functions to child components.

**Example**

```jsx
import { useCallback, useState } from "react";

function App() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    console.log("Clicked");
  }, []);

  return <button onClick={handleClick}>{count}</button>;
}
```

Without `useCallback`, function recreates every render.

---

### **148. Code Splitting**

**Answer:**
Code splitting means splitting your bundle into smaller chunks so only required code loads when needed. This improves performance and initial load time.

Instead of loading entire app at once, load components on demand.

**Example concept**

```
Home.js
Dashboard.js
Settings.js
```

Load only when route opens.

---

### **149. Lazy Loading**

**Answer:**
Lazy loading loads components only when they are needed. Used with routing and heavy components.

Benefits:

* Faster initial load
* Smaller bundle

---

### **150. React.lazy**

**Answer:**
`React.lazy` is used to lazy load components dynamically.

**Example**

```jsx
import React, { Suspense } from "react";

const Dashboard = React.lazy(() => import("./Dashboard"));

function App() {
  return (
    <Suspense fallback={<h1>Loading...</h1>}>
      <Dashboard />
    </Suspense>
  );
}
```

Dashboard loads only when needed.

---

### **151. Suspense**

**Answer:**
`Suspense` shows fallback UI while lazy component loads.

**Example**

```jsx
<Suspense fallback={<h1>Loading...</h1>}>
  <Component />
</Suspense>
```

Fallback could be:

* loader
* spinner
* skeleton

Used with:

* React.lazy
* data fetching (future React features)

---

### **152. Avoid Re-renders**

**Answer:**
Unnecessary re-renders slow down app.

Ways to avoid:

* React.memo
* useMemo
* useCallback
* correct key usage
* split components

Bad example:

```jsx
<Child data={{ name: "Adity" }} />
```

Creates new object each render.

Better:

```jsx
const data = useMemo(() => ({ name: "Adity" }), []);
```

---

### **153. Virtualization**

**Answer:**
Virtualization is used when rendering large lists (1000+ items). Instead of rendering all items, React renders only visible items.

Libraries:

* react-window
* react-virtualized

**Example concept**
Instead of rendering 10,000 rows:

* render only visible rows
* improves performance

Example using react-window:

```jsx
import { FixedSizeList as List } from "react-window";

function App() {
  return (
    <List height={300} itemCount={1000} itemSize={35} width={300}>
      {({ index, style }) => (
        <div style={style}>Row {index}</div>
      )}
    </List>
  );
}
```

---
## üü¢ 20. Error Handling

---

### **154. Error Boundaries**

**Answer:**
Error Boundaries are React components that catch JavaScript errors in their child component tree and display a fallback UI instead of crashing the whole app.

They only work in **class components** and catch errors during:

* rendering
* lifecycle methods
* constructors

They do NOT catch:

* event handler errors
* async errors
* server-side errors

**Example**

```jsx
import React from "react";

class ErrorBoundary extends React.Component {
  constructor() {
    super();
    this.state = { hasError: false };
  }

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.log(error, info);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong</h1>;
    }

    return this.props.children;
  }
}
```

Use:

```jsx
<ErrorBoundary>
  <MyComponent />
</ErrorBoundary>
```

If `MyComponent` crashes ‚Üí fallback UI shown.

---

### **155. try-catch in React**

**Answer:**
`try-catch` is used to handle errors in JavaScript functions, especially async operations like API calls.

It does NOT catch rendering errors in components. That‚Äôs what error boundaries are for.

**Example**

```jsx
async function fetchData() {
  try {
    const res = await fetch("/api");
    const data = await res.json();
  } catch (error) {
    console.log("Error:", error);
  }
}
```

Inside event handler:

```jsx
function handleClick() {
  try {
    throw new Error("Error occurred");
  } catch (e) {
    console.log(e.message);
  }
}
```

Use try-catch for:

* API calls
* async code
* event handlers

---

### **156. Fallback UI**

**Answer:**
Fallback UI is shown when an error occurs or while something is loading. It improves user experience.

Example fallback:

* error message
* loader
* retry button

**Error fallback example**

```jsx
if (error) {
  return <h1>Failed to load data</h1>;
}
```

With ErrorBoundary:

```jsx
render() {
  if (this.state.hasError) {
    return <h1>Something went wrong</h1>;
  }
  return this.props.children;
}
```

Loading fallback:

```jsx
<Suspense fallback={<h1>Loading...</h1>}>
  <Component />
</Suspense>
```

---

### **157. Logging Errors**

**Answer:**
Logging errors helps track bugs in production.

Ways to log errors:

#### 1. Console logging

```jsx
console.error(error);
```

#### 2. ErrorBoundary logging

```jsx
componentDidCatch(error, info) {
  console.log("Error:", error);
}
```

#### 3. External services

Use services like:

* Sentry
* LogRocket
* Firebase Crashlytics

Example:

```js
import * as Sentry from "@sentry/react";

Sentry.captureException(error);
```

Logging helps:

* debug issues
* monitor production
* improve stability

---
## üü¢ 21. Refs & DOM

---

### **158. Refs Introduction**

**Answer:**
Refs (short for *references*) are used in React to directly access DOM elements or store mutable values that do not trigger re-renders. Normally React follows a declarative approach where UI updates automatically based on state and props. But sometimes we need direct access to DOM nodes, and that‚Äôs where refs are used.

Common use cases:

* Focusing input fields
* Playing videos
* Measuring element size
* Integrating third-party libraries
* Scroll control

Refs provide a way to interact with DOM elements without re-rendering the component.

---

### **159. useRef**

**Answer:**
`useRef` is a React hook used to create a reference to a DOM element or store a mutable value that persists across renders.

Syntax:

```jsx
const ref = useRef(initialValue);
```

It returns an object:

```
{ current: value }
```

#### Example: Access DOM element

```jsx
import { useRef } from "react";

function App() {
  const inputRef = useRef();

  function focusInput() {
    inputRef.current.focus();
  }

  return (
    <div>
      <input ref={inputRef} />
      <button onClick={focusInput}>Focus</button>
    </div>
  );
}
```

#### Example: Store value without re-render

```jsx
const countRef = useRef(0);

function handleClick() {
  countRef.current += 1;
  console.log(countRef.current);
}
```

Changing `ref.current` does not cause re-render.

---

### **160. Forward Refs**

**Answer:**
By default, refs cannot be passed to custom components. To allow a parent component to access a child‚Äôs DOM node, we use `forwardRef`.

This is useful when building reusable components like custom inputs, modals, etc.

**Example**

```jsx
import React, { useRef, forwardRef } from "react";

const Input = forwardRef((props, ref) => {
  return <input ref={ref} />;
});

function App() {
  const inputRef = useRef();

  return (
    <div>
      <Input ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>
        Focus Input
      </button>
    </div>
  );
}
```

Here, parent component can focus child input using ref.

---

### **161. DOM Manipulation**

**Answer:**
React generally avoids direct DOM manipulation because it uses Virtual DOM. But sometimes direct access is needed.

Use cases:

* focus input
* scroll to element
* measure height/width
* animations

**Example: Measure height**

```jsx
import { useRef, useEffect } from "react";

function App() {
  const divRef = useRef();

  useEffect(() => {
    console.log(divRef.current.offsetHeight);
  }, []);

  return <div ref={divRef}>Hello</div>;
}
```

**Example: Scroll to element**

```jsx
const sectionRef = useRef();

function scrollToSection() {
  sectionRef.current.scrollIntoView({ behavior: "smooth" });
}
```

Direct DOM manipulation should be minimal and controlled.

---

### **162. Focus Management**

**Answer:**
Focus management improves accessibility and user experience. It ensures correct element is focused when UI updates.

Common scenarios:

* Auto-focus input
* Focus after modal open
* Focus after form submit

**Example: Auto focus**

```jsx
import { useRef, useEffect } from "react";

function App() {
  const inputRef = useRef();

  useEffect(() => {
    inputRef.current.focus();
  }, []);

  return <input ref={inputRef} />;
}
```

**Example: Focus after button click**

```jsx
function App() {
  const inputRef = useRef();

  return (
    <div>
      <input ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>
        Focus
      </button>
    </div>
  );
}
```

Focus management is important for:

* accessibility (keyboard users)
* modals
* forms
* search bars

---

## üü¢ 22. Higher Order Concepts

---

### **163. Higher Order Components (HOC)**

**Answer:**
A Higher Order Component (HOC) is a function that takes a component and returns a new component with additional functionality. It is used to reuse logic across multiple components.

HOC does not modify the original component. Instead, it wraps it and adds extra behavior like authentication, logging, permissions, etc.

**Syntax**

```jsx
const EnhancedComponent = withSomething(OriginalComponent);
```

**Example: Authentication HOC**

```jsx
function withAuth(Component) {
  return function WrappedComponent(props) {
    const isLoggedIn = true;

    if (!isLoggedIn) {
      return <h1>Please login</h1>;
    }

    return <Component {...props} />;
  };
}
```

Use:

```jsx
function Dashboard() {
  return <h1>Dashboard</h1>;
}

export default withAuth(Dashboard);
```

Now `Dashboard` will only render if user is logged in.

**Common uses of HOC**

* Authentication
* Authorization
* Logging
* Data fetching
* Permissions

---

### **164. Render Props**

**Answer:**
Render props is a technique where a component receives a function as a prop and uses that function to render UI. This helps share logic between components.

**Example**

```jsx
function DataProvider({ render }) {
  const name = "Adity";
  return render(name);
}
```

Use:

```jsx
<DataProvider render={(name) => <h1>Hello {name}</h1>} />
```

Another example:

```jsx
function MouseTracker({ render }) {
  const [pos, setPos] = React.useState({ x: 0, y: 0 });

  return (
    <div onMouseMove={(e) => setPos({ x: e.clientX, y: e.clientY })}>
      {render(pos)}
    </div>
  );
}

<MouseTracker render={(pos) => (
  <h1>{pos.x}, {pos.y}</h1>
)} />
```

Render props allow flexible logic sharing.

---

### **165. Compound Components**

**Answer:**
Compound components are components that work together to form a complete UI. They share state internally and communicate with each other.

Used in:

* Tabs
* Accordion
* Dropdown
* Modal

Example structure:

```
<Tabs>
  <Tabs.List />
  <Tabs.Panel />
</Tabs>
```

**Example**

```jsx
const TabsContext = React.createContext();

function Tabs({ children }) {
  const [active, setActive] = React.useState(0);

  return (
    <TabsContext.Provider value={{ active, setActive }}>
      {children}
    </TabsContext.Provider>
  );
}

function TabButton({ index, children }) {
  const { setActive } = React.useContext(TabsContext);
  return <button onClick={() => setActive(index)}>{children}</button>;
}

function TabPanel({ index, children }) {
  const { active } = React.useContext(TabsContext);
  return active === index ? <div>{children}</div> : null;
}
```

Use:

```jsx
<Tabs>
  <TabButton index={0}>Tab 1</TabButton>
  <TabButton index={1}>Tab 2</TabButton>

  <TabPanel index={0}>Content 1</TabPanel>
  <TabPanel index={1}>Content 2</TabPanel>
</Tabs>
```

Compound components provide flexible API.

---

### **166. Controlled vs Uncontrolled Patterns**

**Answer:**
These patterns describe how data is managed inside components.

---

#### Controlled Components

React controls the component using state.

**Example**

```jsx
import { useState } from "react";

function Input() {
  const [value, setValue] = useState("");

  return (
    <input
      value={value}
      onChange={(e) => setValue(e.target.value)}
    />
  );
}
```

Here React controls the input value.

---

#### Uncontrolled Components

DOM controls the value using ref.

**Example**

```jsx
import { useRef } from "react";

function Input() {
  const inputRef = useRef();

  function handleSubmit() {
    console.log(inputRef.current.value);
  }

  return (
    <div>
      <input ref={inputRef} />
      <button onClick={handleSubmit}>Submit</button>
    </div>
  );
}
```

React does not manage state here.

---

### **Controlled vs Uncontrolled Comparison**

| Controlled      | Uncontrolled      |
| --------------- | ----------------- |
| Uses state      | Uses ref          |
| More control    | Less control      |
| Easy validation | Harder validation |
| Recommended     | Rare use          |

---
## üü¢ 23. Testing

---

### **167. Testing Basics**

**Answer:**
Testing in React ensures that your components and logic work correctly. It helps catch bugs early and improves code quality. Testing checks whether UI behaves as expected when users interact with it.

Main goals:

* Verify UI output
* Test user interactions
* Prevent bugs
* Ensure reliability

Types of testing in React:

* Unit testing
* Integration testing
* End-to-end testing

React commonly uses:

* Jest
* React Testing Library

---

### **168. Unit Testing**

**Answer:**
Unit testing tests a single function or component in isolation. It checks if a component behaves correctly with given inputs.

Example: testing a button component.

**Component**

```jsx
function Button({ text }) {
  return <button>{text}</button>;
}
export default Button;
```

**Test**

```jsx
import { render, screen } from "@testing-library/react";
import Button from "./Button";

test("renders button text", () => {
  render(<Button text="Click" />);
  expect(screen.getByText("Click")).toBeInTheDocument();
});
```

Unit tests focus on small pieces of code.

---

### **169. Integration Testing**

**Answer:**
Integration testing checks how multiple components work together. It tests real user behavior like form submission, navigation, API calls, etc.

Example: form + submit.

```jsx
test("form submit works", () => {
  render(<Form />);
  
  const input = screen.getByPlaceholderText("Name");
  const button = screen.getByText("Submit");

  fireEvent.change(input, { target: { value: "Adity" } });
  fireEvent.click(button);

  expect(screen.getByText("Submitted")).toBeInTheDocument();
});
```

Integration testing ensures components interact correctly.

---

### **170. Jest**

**Answer:**
Jest is a JavaScript testing framework used with React. It provides test runner, assertions, mocks, and snapshot testing.

Install:

```bash
npm install --save-dev jest
```

Basic test:

```js
test("adds numbers", () => {
  expect(2 + 2).toBe(4);
});
```

Jest features:

* test runner
* mocking
* snapshot testing
* coverage reports

---

### **171. React Testing Library**

**Answer:**
React Testing Library tests React components by focusing on user behavior rather than implementation details. It encourages testing UI as a user would see it.

Install:

```bash
npm install @testing-library/react
```

Example:

```jsx
import { render, screen } from "@testing-library/react";
import App from "./App";

test("renders hello text", () => {
  render(<App />);
  expect(screen.getByText("Hello")).toBeInTheDocument();
});
```

Why use it:

* tests real user behavior
* avoids testing internal implementation
* recommended by React team

---

### **172. Mocking APIs**

**Answer:**
Mocking APIs means simulating API responses during tests so you don‚Äôt call real servers.

Using Jest mock:

```js
jest.mock("axios");
```

Example:

```jsx
import axios from "axios";

axios.get.mockResolvedValue({
  data: [{ id: 1, name: "Adity" }]
});
```

Test:

```jsx
test("fetches data", async () => {
  render(<Users />);

  const user = await screen.findByText("Adity");
  expect(user).toBeInTheDocument();
});
```

Mocking helps:

* faster tests
* predictable results
* no real API calls

---

### **173. Snapshot Testing**

**Answer:**
Snapshot testing saves a snapshot of component UI and compares it on future tests. If UI changes unexpectedly, test fails.

Example:

```jsx
import renderer from "react-test-renderer";
import Button from "./Button";

test("matches snapshot", () => {
  const tree = renderer.create(<Button />).toJSON();
  expect(tree).toMatchSnapshot();
});
```

Jest stores snapshot file:

```
__snapshots__/
```

If UI changes ‚Üí snapshot mismatch.

Use snapshot testing for:

* stable UI
* preventing accidental changes

Avoid using for:

* frequently changing UI

---
## üü¢ 24. Security

---

### **174. XSS in React**

**Answer:**
XSS (Cross-Site Scripting) is a security vulnerability where attackers inject malicious JavaScript into a web application. If executed in the browser, it can steal cookies, tokens, or user data.

React helps prevent XSS by **escaping content automatically** when rendering JSX. This means if a user types `<script>`, React renders it as text instead of executing it.

**Safe example**

```jsx
function App() {
  const userInput = "<script>alert('hack')</script>";
  return <div>{userInput}</div>;
}
```

Output shows text, not script execution.

However, React can be vulnerable if you use:

```
dangerouslySetInnerHTML
```

**Dangerous example**

```jsx
<div dangerouslySetInnerHTML={{ __html: userInput }} />
```

This allows raw HTML injection and can cause XSS if not sanitized.

**Prevention tips**

* Avoid `dangerouslySetInnerHTML`
* Sanitize user input
* Use trusted libraries
* Validate data

---

### **175. Sanitizing Inputs**

**Answer:**
Sanitizing means cleaning user input to remove harmful scripts or HTML before rendering.

When user input comes from:

* forms
* search
* comments
* rich text editors

You should sanitize before displaying.

Library:

```
DOMPurify
```

Install:

```bash
npm install dompurify
```

**Example**

```jsx
import DOMPurify from "dompurify";

function App() {
  const dirty = "<img src=x onerror=alert(1) />";
  const clean = DOMPurify.sanitize(dirty);

  return <div dangerouslySetInnerHTML={{ __html: clean }} />;
}
```

Always sanitize if rendering HTML from user input.

---

### **176. Secure API Calls**

**Answer:**
When making API calls in React, security is important to protect data and users.

Best practices:

#### 1. Use HTTPS

Always use secure endpoints:

```
https://api.com
```

#### 2. Authentication tokens

Send tokens in headers:

```js
axios.get("/api", {
  headers: {
    Authorization: `Bearer ${token}`
  }
});
```

#### 3. Never store secrets in frontend

Do NOT store:

* API keys
* private keys
* database credentials

Frontend code is public.

#### 4. Use environment variables

Store API URLs and public keys safely.

#### 5. Handle errors securely

Do not expose server errors to users.

---

### **177. Environment Variables**

**Answer:**
Environment variables store configuration values like API URLs and keys. They prevent hardcoding sensitive data.

Create `.env` file:

For Vite:

```
VITE_API_URL=https://api.com
```

For CRA:

```
REACT_APP_API_URL=https://api.com
```

Use in code:

```js
const api = import.meta.env.VITE_API_URL;
```

or CRA:

```js
process.env.REACT_APP_API_URL
```

Important rules:

* Never commit secrets
* Add `.env` to `.gitignore`
* Only expose public keys

Use cases:

* API base URL
* environment mode
* feature flags

---
## üü¢ 25. Deployment

---

### **178. Production Build**

**Answer:**
A production build is an optimized version of your React app ready for deployment. It removes development tools, minifies code, and improves performance.

In development:

* large bundle
* debugging enabled
* slower

In production:

* optimized code
* smaller bundle
* faster load

**Create production build**

For Vite:

```bash
npm run build
```

For CRA:

```bash
npm run build
```

This creates:

```
dist/   (Vite)
build/  (CRA)
```

These files are uploaded to hosting platforms.

---

### **179. Environment Config**

**Answer:**
Environment configuration allows different settings for development and production.

Example:

* dev API ‚Üí localhost
* prod API ‚Üí real server

Create `.env` files:

```
.env
.env.production
.env.development
```

Vite example:

```
VITE_API_URL=https://api.com
```

Use:

```js
const url = import.meta.env.VITE_API_URL;
```

Never store:

* secret keys
* passwords
* private tokens

Add `.env` to `.gitignore`.

---

### **180. Hosting on Netlify**

**Answer:**
Netlify is a popular hosting platform for React apps.

#### Steps

1. Push project to GitHub
2. Go to Netlify
3. Click **New Site from Git**
4. Connect GitHub repo
5. Build settings:

For Vite:

```
Build command: npm run build
Publish directory: dist
```

For CRA:

```
Build command: npm run build
Publish directory: build
```

6. Deploy

Netlify automatically builds and deploys.

#### Features

* free hosting
* custom domain
* auto deploy on git push
* environment variables

---

### **181. Hosting on Vercel**

**Answer:**
Vercel is another popular hosting platform, especially for React and Next.js.

#### Steps

1. Push code to GitHub
2. Go to Vercel
3. Import project
4. Select repo
5. Click deploy

Vercel auto-detects React settings.

#### Features

* fast CDN
* auto deployment
* preview deployments
* environment variables

Add env variables in:

```
Project Settings ‚Üí Environment Variables
```

---

### **182. CI/CD Basics**

**Answer:**
CI/CD means:

* CI ‚Üí Continuous Integration
* CD ‚Üí Continuous Deployment

It automates testing and deployment.

Flow:

```
Push code ‚Üí run tests ‚Üí build ‚Üí deploy
```

Example GitHub ‚Üí Netlify:

1. Push to GitHub
2. Netlify detects change
3. Runs build
4. Deploys automatically

#### CI/CD tools

* GitHub Actions
* Netlify CI
* Vercel CI
* Jenkins

**Example GitHub Action**

```yaml
name: Deploy

on: push

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - run: npm install
      - run: npm run build
```

Benefits:

* automatic deployment
* fewer errors
* faster delivery

---
## üü¢ 26. Advanced React

---

### **183. Concurrent Rendering**

**Answer:**
Concurrent Rendering is a React feature that allows React to prepare multiple UI updates at the same time and choose the most important one to render first. It improves performance and responsiveness.

Instead of blocking the UI while rendering a big update, React can pause, resume, or cancel rendering work.

Benefits:

* smoother UI
* faster interactions
* better user experience

Example scenario:
User types in search ‚Üí React updates input immediately while preparing list rendering in background.

React 18 introduced concurrent features like:

* `startTransition`
* `useTransition`
* `useDeferredValue`

**Example**

```jsx
import { useState, useTransition } from "react";

function App() {
  const [text, setText] = useState("");
  const [list, setList] = useState([]);
  const [isPending, startTransition] = useTransition();

  function handleChange(e) {
    const value = e.target.value;
    setText(value);

    startTransition(() => {
      const items = Array(5000).fill(value);
      setList(items);
    });
  }

  return (
    <div>
      <input onChange={handleChange} />
      {isPending && <p>Loading...</p>}
      {list.map((item, i) => <p key={i}>{item}</p>)}
    </div>
  );
}
```

Here heavy update runs in background.

---

### **184. React Fiber**

**Answer:**
React Fiber is the new reconciliation engine introduced in React 16. It allows React to break rendering work into smaller units and prioritize tasks.

Before Fiber:

* rendering was synchronous
* large updates blocked UI

After Fiber:

* rendering is incremental
* tasks can pause and resume
* better performance

Fiber enables:

* concurrent rendering
* error boundaries
* suspense
* scheduling

Developers don‚Äôt directly interact with Fiber, but it powers React internally.

---

### **185. Suspense for Data Fetching**

**Answer:**
Suspense allows components to wait for something (like data or lazy-loaded components) before rendering.

Previously used only for lazy loading. Now also for data fetching in advanced setups.

Basic example:

```jsx
import React, { Suspense } from "react";

const Page = React.lazy(() => import("./Page"));

function App() {
  return (
    <Suspense fallback={<h1>Loading...</h1>}>
      <Page />
    </Suspense>
  );
}
```

Future React supports:

* Suspense with data fetching
* async rendering

Libraries using Suspense:

* React Query
* Relay

---

### **186. Server Components**

**Answer:**
Server Components allow some React components to run on the server instead of browser. They reduce bundle size and improve performance.

Benefits:

* smaller JS bundle
* faster load
* secure data fetching

Server component example (concept):

```jsx
async function Page() {
  const data = await fetchData();
  return <div>{data}</div>;
}
```

Used in:

* Next.js
* React Server Components architecture

Client components handle interactions.
Server components handle data fetching.

---

### **187. Hydration**

**Answer:**
Hydration is the process where React attaches event listeners to server-rendered HTML on the client.

Steps:

1. Server sends HTML
2. Browser displays HTML
3. React attaches JS ‚Üí becomes interactive

Without hydration ‚Üí static HTML only.

Example:

```jsx
hydrateRoot(document.getElementById("root"), <App />);
```

Used in:

* SSR (server-side rendering)
* Next.js

---

### **188. Streaming**

**Answer:**
Streaming allows server to send HTML in chunks instead of waiting for entire page to render. This improves performance and perceived speed.

Instead of:

```
Wait ‚Üí full page ‚Üí send
```

Streaming:

```
Send header ‚Üí send sections ‚Üí send rest
```

React 18 supports streaming SSR.

Benefits:

* faster first paint
* better UX
* progressive loading

Used in:

* Next.js
* React server rendering

---

### **189. React 18 Features**

**Answer:**
React 18 introduced major improvements.

Key features:

#### 1. Automatic batching

Multiple state updates grouped together.

```jsx
setCount(c+1);
setName("A");
```

Now re-renders once.

---

#### 2. Concurrent rendering

Background rendering for smoother UI.

---

#### 3. startTransition

Mark updates as low priority.

```jsx
startTransition(() => {
  setData(newData);
});
```

---

#### 4. useTransition

Shows loading state during transitions.

---

#### 5. Suspense improvements

Better lazy loading and data handling.

---

#### 6. Streaming SSR

Faster server rendering.

---

#### 7. New root API

```jsx
import { createRoot } from "react-dom/client";

createRoot(root).render(<App />);
```

---
## üü¢ 27. React with TypeScript

---

### **190. TypeScript Basics**

**Answer:**
TypeScript is a superset of JavaScript that adds static typing. It helps catch errors at compile time and improves code quality and maintainability.

Benefits:

* type safety
* better autocomplete
* fewer runtime errors
* easier refactoring

Basic types:

```ts
let name: string = "Adity";
let age: number = 22;
let isAdmin: boolean = true;
```

Arrays:

```ts
let nums: number[] = [1, 2, 3];
```

Functions:

```ts
function add(a: number, b: number): number {
  return a + b;
}
```

In React, TypeScript helps type props, state, hooks, etc.

---

### **191. Typing Props**

**Answer:**
Props should be typed to ensure correct data is passed to components.

Using interface:

```tsx
interface Props {
  name: string;
  age: number;
}
```

Component:

```tsx
function User({ name, age }: Props) {
  return <h1>{name} - {age}</h1>;
}
```

Usage:

```tsx
<User name="Adity" age={22} />
```

Optional prop:

```ts
interface Props {
  name: string;
  age?: number;
}
```

Default value:

```tsx
function User({ name, age = 18 }: Props) {}
```

---

### **192. Typing State**

**Answer:**
State can be typed using generics in `useState`.

**Example**

```tsx
import { useState } from "react";

const [count, setCount] = useState<number>(0);
```

Object state:

```tsx
interface User {
  name: string;
  age: number;
}

const [user, setUser] = useState<User>({
  name: "",
  age: 0
});
```

Array state:

```tsx
const [items, setItems] = useState<string[]>([]);
```

Union type:

```tsx
const [value, setValue] = useState<string | null>(null);
```

---

### **193. Typing Hooks**

**Answer:**

#### useRef

```tsx
const inputRef = useRef<HTMLInputElement>(null);
```

#### useEffect

```tsx
useEffect((): void => {
  console.log("Mounted");
}, []);
```

#### useReducer

```tsx
interface State {
  count: number;
}

type Action = { type: "inc" } | { type: "dec" };

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case "inc":
      return { count: state.count + 1 };
    case "dec":
      return { count: state.count - 1 };
  }
}
```

---

### **194. Generics in React**

**Answer:**
Generics allow reusable components and functions that work with multiple types.

Example generic component:

```tsx
interface Props<T> {
  items: T[];
}

function List<T>({ items }: Props<T>) {
  return (
    <ul>
      {items.map((item, i) => (
        <li key={i}>{JSON.stringify(item)}</li>
      ))}
    </ul>
  );
}
```

Use:

```tsx
<List<string> items={["A", "B"]} />
<List<number> items={[1, 2]} />
```

Generic hook:

```tsx
function useFetch<T>(url: string): T | null {
  const [data, setData] = useState<T | null>(null);
  return data;
}
```

---

### **195. Interfaces vs Types**

**Answer:**
Both `interface` and `type` define shapes of objects.

#### Interface

```ts
interface User {
  name: string;
  age: number;
}
```

#### Type

```ts
type User = {
  name: string;
  age: number;
};
```

Differences:

| Interface           | Type                   |
| ------------------- | ---------------------- |
| extendable          | flexible               |
| good for objects    | supports unions        |
| preferred for props | good for complex types |

Interface extend:

```ts
interface Admin extends User {
  role: string;
}
```

Type union:

```ts
type Status = "loading" | "success";
```

Best practice:

* use interface for components/props
* use type for unions & advanced types

---
## üü¢ 28. Architecture & Patterns

---

### **196. Folder Structure Patterns**

**Answer:**
Folder structure defines how files are organized in a React project. A good structure improves maintainability, scalability, and collaboration.

#### Basic structure (small apps)

```
src/
 ‚îú‚îÄ‚îÄ components/
 ‚îú‚îÄ‚îÄ pages/
 ‚îú‚îÄ‚îÄ App.jsx
 ‚îî‚îÄ‚îÄ main.jsx
```

#### Scalable structure (recommended)

```
src/
 ‚îú‚îÄ‚îÄ components/
 ‚îú‚îÄ‚îÄ pages/
 ‚îú‚îÄ‚îÄ hooks/
 ‚îú‚îÄ‚îÄ services/
 ‚îú‚îÄ‚îÄ store/
 ‚îú‚îÄ‚îÄ utils/
 ‚îú‚îÄ‚îÄ assets/
 ‚îî‚îÄ‚îÄ routes/
```

#### Large app structure

```
src/
 ‚îú‚îÄ‚îÄ features/
 ‚îÇ   ‚îú‚îÄ‚îÄ auth/
 ‚îÇ   ‚îú‚îÄ‚îÄ dashboard/
 ‚îÇ   ‚îî‚îÄ‚îÄ profile/
 ‚îú‚îÄ‚îÄ shared/
 ‚îú‚îÄ‚îÄ layouts/
 ‚îî‚îÄ‚îÄ config/
```

Best practices:

* group related files
* avoid deep nesting
* use meaningful names
* keep components reusable

---

### **197. Atomic Design**

**Answer:**
Atomic Design is a design methodology that breaks UI into small reusable components.

Levels:

1. Atoms
2. Molecules
3. Organisms
4. Templates
5. Pages

#### Atoms

Basic elements:

```
Button
Input
Label
```

#### Molecules

Combination of atoms:

```
SearchBox = Input + Button
```

#### Organisms

Complex UI blocks:

```
Navbar
Card
Sidebar
```

#### Templates

Layout structure.

#### Pages

Final UI screens.

**Example structure**

```
components/
 ‚îú‚îÄ‚îÄ atoms/
 ‚îú‚îÄ‚îÄ molecules/
 ‚îú‚îÄ‚îÄ organisms/
```

Benefits:

* reusable UI
* scalable design
* consistent UI

---

### **198. Feature-based Structure**

**Answer:**
Feature-based structure groups files by feature instead of type. Each feature has its own components, hooks, and services.

Example:

```
src/
 ‚îú‚îÄ‚îÄ features/
 ‚îÇ   ‚îú‚îÄ‚îÄ auth/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Login.jsx
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authSlice.js
 ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api.js
 ‚îÇ   ‚îú‚îÄ‚îÄ cart/
 ‚îÇ   ‚îî‚îÄ‚îÄ products/
```

Benefits:

* scalable
* easy maintenance
* modular
* team-friendly

Recommended for:

* large apps
* enterprise apps

---

### **199. Separation of Concerns**

**Answer:**
Separation of concerns means separating logic, UI, and data into different parts to keep code clean and maintainable.

Example:

```
Component ‚Üí UI
Hook ‚Üí logic
Service ‚Üí API calls
```

Bad:

```jsx
// UI + API + logic mixed
```

Good:

```
hooks/useUser.js
services/api.js
components/User.jsx
```

Example:

```jsx
// useUser.js
export function useUser() {
  const [user, setUser] = useState(null);
}
```

```jsx
// User.jsx
const user = useUser();
```

Benefits:

* reusable code
* easier testing
* cleaner structure

---

### **200. Clean Code Practices**

**Answer:**
Clean code makes code readable, maintainable, and scalable.

Best practices:

#### 1. Use meaningful names

Bad:

```js
const a = 5;
```

Good:

```js
const totalPrice = 5;
```

#### 2. Small components

Break large components into smaller ones.

#### 3. Avoid duplication

Reuse components and hooks.

#### 4. Keep functions simple

One function = one task.

#### 5. Use hooks for logic

Move logic into custom hooks.

#### 6. Consistent formatting

Use:

* ESLint
* Prettier

#### 7. Avoid deep nesting

Keep code readable.

#### 8. Use proper folder structure

---

### Clean Component Example

Bad:

```jsx
function App() {
  // 500 lines
}
```

Good:

```jsx
function App() {
  return (
    <>
      <Header />
      <Dashboard />
      <Footer />
    </>
  );
}
```

---
## üü¢ 29. Real-World & Interview Topics

---

### **201. Props Drilling**

**Answer:**
Props drilling happens when data is passed from a parent component to deeply nested child components through multiple intermediate components that don‚Äôt actually need the data.

Structure:

```
App ‚Üí Parent ‚Üí Child ‚Üí GrandChild
```

All components must pass props manually.

**Example**

```jsx
function App() {
  const user = "Adity";
  return <Parent user={user} />;
}

function Parent({ user }) {
  return <Child user={user} />;
}

function Child({ user }) {
  return <h1>{user}</h1>;
}
```

Problems:

* messy code
* hard to maintain
* unnecessary prop passing

**Solution**

* Context API
* Redux
* Zustand

---

### **202. State Lifting**

**Answer:**
State lifting means moving state to the nearest common parent so multiple components can share it.

Used when:

* two components need same data

**Example**

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  return (
    <>
      <ChildA count={count} />
      <ChildB setCount={setCount} />
    </>
  );
}
```

Child A displays value
Child B updates value

State lives in parent ‚Üí shared across children.

---

### **203. Anti-patterns**

**Answer:**
Anti-patterns are bad practices that can cause bugs or performance issues.

Common React anti-patterns:

#### 1. Mutating state directly

Bad:

```jsx
state.count++;
```

Good:

```jsx
setCount(count + 1);
```

#### 2. Using index as key

```jsx
key={index}
```

Bad when list changes.

#### 3. Too many states

Use object state instead.

#### 4. Large components

Split into smaller components.

#### 5. Side effects in render

Avoid API calls inside render.

---

### **204. Memory Leaks**

**Answer:**
Memory leaks occur when components keep running background tasks even after unmounting.

Causes:

* timers
* event listeners
* API calls

**Example problem**

```jsx
useEffect(() => {
  setInterval(() => {
    console.log("Running");
  }, 1000);
}, []);
```

Interval never stops.

**Fix**

```jsx
useEffect(() => {
  const id = setInterval(() => {}, 1000);

  return () => clearInterval(id);
}, []);
```

Always clean up:

* timers
* subscriptions
* listeners

---

### **205. Infinite Loops**

**Answer:**
Infinite loop happens when `useEffect` updates state and runs again repeatedly.

Bad:

```jsx
useEffect(() => {
  setCount(count + 1);
});
```

Runs forever.

Fix:

```jsx
useEffect(() => {
  setCount(5);
}, []);
```

Or:

```jsx
useEffect(() => {
  setCount(count + 1);
}, [count]);
```

Always use dependency array carefully.

---

### **206. Controlled Re-rendering**

**Answer:**
Re-render happens when state or props change. Too many re-renders slow app.

Ways to control:

* React.memo
* useMemo
* useCallback
* split components

Example:

```jsx
const Child = React.memo(({ name }) => {
  return <h1>{name}</h1>;
});
```

Child re-renders only if `name` changes.

---

### **207. Optimization Strategies**

**Answer:**
Techniques to improve performance:

1. React.memo ‚Üí avoid re-render
2. useMemo ‚Üí cache values
3. useCallback ‚Üí cache functions
4. Lazy loading ‚Üí load when needed
5. Code splitting
6. Virtualization
7. Proper key usage
8. Avoid large state

Example:

```jsx
const memoValue = useMemo(() => heavyCalc(), []);
```

---

### **208. Common Interview Questions**

**Answer:**
Most asked React interview questions:

**Basics**

* What is Virtual DOM?
* Props vs State?
* useEffect vs useLayoutEffect?
* Controlled vs uncontrolled?

**Intermediate**

* Context vs Redux?
* useMemo vs useCallback?
* React lifecycle?
* Keys in React?

**Advanced**

* Concurrent rendering?
* React Fiber?
* Performance optimization?
* SSR vs CSR?

**Coding questions**

* Build todo app
* Search filter
* API fetch
* Counter with hooks

---
## üü¢ 30. Ecosystem & Tools

---

### **209. ESLint**

**Answer:**
ESLint is a tool that analyzes your JavaScript/React code and finds problems or bad practices. It helps maintain clean and consistent code.

It checks:

* syntax errors
* unused variables
* wrong patterns
* code quality

Install:

```bash
npm install eslint --save-dev
```

Initialize:

```bash
npx eslint --init
```

Example rule:

```js
no-unused-vars: "error"
```

React ESLint plugin:

```bash
npm install eslint-plugin-react
```

Benefits:

* prevents bugs
* consistent coding style
* improves readability
* team-friendly

---

### **210. Prettier**

**Answer:**
Prettier is a code formatter. It automatically formats your code to keep consistent style.

It handles:

* spacing
* semicolons
* quotes
* indentation

Install:

```bash
npm install prettier --save-dev
```

Create config:

```
.prettierrc
```

Example:

```json
{
  "semi": true,
  "singleQuote": true
}
```

Format code:

```bash
npx prettier --write .
```

Use with ESLint for best results.

---

### **211. Husky**

**Answer:**
Husky is a tool that runs scripts before Git commits or pushes. It helps enforce rules like linting and tests before code is committed.

Install:

```bash
npm install husky --save-dev
```

Enable:

```bash
npx husky install
```

Add hook:

```bash
npx husky add .husky/pre-commit "npm test"
```

Now before commit ‚Üí tests run automatically.

Benefits:

* prevents bad commits
* enforces linting
* improves code quality

---

### **212. Git Hooks**

**Answer:**
Git hooks are scripts that run automatically at certain Git events like commit, push, etc.

Common hooks:

* pre-commit
* pre-push
* commit-msg

Example:

```
pre-commit ‚Üí run lint
pre-push ‚Üí run tests
```

Example setup with Husky:

```bash
npx husky add .husky/pre-commit "npm run lint"
```

This ensures code quality before pushing.

---

### **213. Storybook**

**Answer:**
Storybook is a tool for developing and testing UI components in isolation. It allows building components separately from the main app.

Install:

```bash
npx storybook@latest init
```

Create story:

```
Button.stories.js
```

Example:

```jsx
import Button from "./Button";

export default {
  title: "Button",
  component: Button
};

export const Primary = () => <Button text="Click" />;
```

Benefits:

* component testing
* UI documentation
* reusable components
* design system

Used in large apps and teams.

---

### **214. React DevTools**

**Answer:**
React DevTools is a browser extension used to inspect React components and state.

Available for:

* Chrome
* Firefox

Features:

* inspect component tree
* view props & state
* debug hooks
* performance profiling

Example usage:

1. Open browser dev tools
2. Click React tab
3. Inspect components

You can:

* see state changes
* track re-renders
* debug issues

Performance tab shows slow components.

---
